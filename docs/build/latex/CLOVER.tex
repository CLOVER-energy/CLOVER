%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{CLOVER Documentation}
\date{Dec 03, 2021}
\release{4.0.1}
\author{Philip Sandwell}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{index:overview}}
\sphinxAtStartPar
CLOVER \sphinxhyphen{} Continuous Lifetime Optimisation of Variable Electricity Resources \sphinxhyphen{} is
a free, open\sphinxhyphen{}source tool for modelling, simulating, optimising and analysing the
performance and impacts of electricity systems. Originally designed for off\sphinxhyphen{}grid
solar and battery minigrids for rural electrification in developing
countries, CLOVER now includes the functionality to use solar, battery storage,
diesel generation and the national grid to supply power to community\sphinxhyphen{}scale
electricity systems.

\sphinxAtStartPar
Its use cases have expanded from simple feasibility studies
to analysis of the long\sphinxhyphen{}term impacts and benefits of sustainable rural
electrification, as well as improving the performance and design of real\sphinxhyphen{}life
systems currently deployed in the field.

\sphinxAtStartPar
CLOVER is designed to be accessible and work on “ordinary” computers and
laptops and, while the processing speeds will vary, the results will be the
same: it has been run on machines varying in capacities from a Raspberry Pi
to a supercomputer cluster. CLOVER is, and always will be, free to use under an
MIT License.


\chapter{About this guide}
\label{\detokenize{index:about-this-guide}}
\sphinxAtStartPar
This guide aims to provide an introduction to the operation and functionality
of CLOVER, as well as an insight into the kinds of investigations it can be
used for. We have aimed to make it as accessible as possible to new users, who
are assumed to have a basic knowledge of programming (limited experience with
some language, not necessarily Python) and a good knowledge of their chosen
situation (moderate or higher experience with the energy access issues and goals
relevant to their context). More advanced users are, of course, very welcome to
dive deeper into CLOVER’s functionality and edit the code to suit their needs.

\sphinxAtStartPar
Each section walks the user through the modules which make up CLOVER, their
core functions, and how they fit together in the entire system. Each module
can be operated independently but we recommend following the order presented in
this guide, as some modules depend on others to function. The sections also
present options for outputs and visualisation of the results.

\sphinxAtStartPar
For coherence with the documentation we recommend that novice users use Spyder
(available by downloading Anaconda) and Python 3.6, which will make this guide
easier to follow and has the requisite packages installed already. This may
also help with the troubleshooting sections throughout this guide.

\sphinxAtStartPar
This guide focuses on the key inputs and outputs of each CLOVER module with the
goal of getting usable, actionable results. For details on the inner workings
of the code, and the exact nature of the functions that it relies on, please
refer to the comments and documentation in the code itself.

\sphinxAtStartPar
For a single PDF document containing all of the information in this guide,
either use the download function (bottom left of the site) or download the user
manual \sphinxhref{https://github.com/phil-sandwell/CLOVER/blob/master/CLOVER\%20User\%20Manual.pdf}{available here}.
This site will be continuously updated and should serve as the main reference,
whilst the user manual will be updated after significant updates to CLOVER.


\section{Introduction}
\label{\detokenize{overview:introduction}}\label{\detokenize{overview::doc}}
\sphinxAtStartPar
This guide provides a guide to using CLOVER following the initial
download. CLOVER is free and open\sphinxhyphen{}source for all to use, and the latest
version of CLOVER is available on
\sphinxhref{https://github.com/phil-sandwell/CLOVER}{GitHub}. Periodic updates
to the code are also posted on Github to increase its functionality and
fix bugs. This document provides examples of how to run the code, how
the different modules and functions operate, and the kinds of outputs
that can be obtained.


\subsection{About CLOVER}
\label{\detokenize{overview:about-clover}}
\sphinxAtStartPar
CLOVER was developed at Imperial College London as a means of
investigating how to support rural electrification strategies in
developing countries. Under continuous development since 2015, CLOVER
has been used for studies of electricity systems in Sub\sphinxhyphen{}Saharan Africa,
South Asia and South America to explore the potential to provide
reliable, affordable and sustainable power to rural and displaced
communities.

\sphinxAtStartPar
CLOVER has the capabilities to model electricity systems of any size,
from those serving individual households to large communities with
diverse uses of energy and beyond, but has most commonly been used for
village\sphinxhyphen{}scale minigrids serving hundreds of users. Its core
functionality is to simulate and optimise systems supplied by any
combination of solar, battery storage, diesel generation and a national
grid connection to supply energy under specified performance parameters.
CLOVER has been used to investigate technical case studies of specific
systems, as well as broader analyses of the effects of rural
electrification policies, for both academic and practitioner\sphinxhyphen{}focused
audiences.

\sphinxAtStartPar
Some open\sphinxhyphen{}source examples of how CLOVER has been used include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Using solar and battery storage minigrids to support an unreliable grid network in rural India (\sphinxhref{https://www.sciencedirect.com/science/article/pii/S1876610217345101}{available here})

\item {} 
\sphinxAtStartPar
Investigating how to support rural electrification policies in Rwanda and Nepal (\sphinxhref{http://www.imperial.ac.uk/grantham/publications/energy-and-low-carbon-futures/supporting-rural-electrification-in-developing-countries.php}{available here})

\item {} 
\sphinxAtStartPar
Exploring the opportunities for solar energy to offset diesel generation in refugee camps (\sphinxhref{https://spiral.imperial.ac.uk:8443/bitstream/10044/1/77296/6/Sustainable\%20mini-grid\%20systems\%20in\%20refugee\%20gamps\%20-\%20Rwanda\%20-\%20web.pdf}{available here})

\end{itemize}

\sphinxAtStartPar
CLOVER has also been used for investigations in several PhD theses (\sphinxhref{https://doi.org/10.25560/58881}{one
example here}) and Master’s theses.
The latter has included investigations into:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Using minigrids to provide power to rural entrepreneurs in Rwanda

\item {} 
\sphinxAtStartPar
Using solar power to provide electricity to health centres in remote areas of Kenya

\item {} 
\sphinxAtStartPar
The opportunities for using health centres as anchor load clients in rural India

\item {} 
\sphinxAtStartPar
Options for supporting electricity for educational purposes at a women’s education centre in Senegal

\item {} 
\sphinxAtStartPar
The benefits of providing electricity for açaí processing in rural Brazil

\item {} 
\sphinxAtStartPar
System design options for minigrids in refugee camps in Djibouti

\end{itemize}


\subsubsection{What is CLOVER for?}
\label{\detokenize{overview:what-is-clover-for}}
\sphinxAtStartPar
CLOVER is a software tool for simulating and optimising community\sphinxhyphen{}scale
electricity systems, typically minigrids to support rural
electrification in developing countries. CLOVER allows users to model
electricity demand and supply in locations and communities at an hourly
resolution, for example allowing them to investigate how a specific
electricity system might perform or to find the generation and storage
capacity required to meet the needs of the community at the lowest cost.
CLOVER can provide an insight into the technical performance, costs, and
environmental impact of a system, and allow the user to evaluate many
different scenarios to decide on the best way to provide sustainable,
affordable and reliable electricity to the community.


\subsubsection{What is CLOVER not for?}
\label{\detokenize{overview:what-is-clover-not-for}}
\sphinxAtStartPar
Fundamentally, CLOVER is an energy balance model which accounts for the
generation and usage of electricity at an hourly resolution. The model
is only as good as its data inputs and so the user should be aware of
the many caveats that are attached to energy system modelling. CLOVER
does not account for technical considerations such as power balancing in
real systems, the compatibility of specific electronic components, or
the many other practical considerations that would be relevant when
designing the exact specifications of a system being deployed in the
field. CLOVER can recommend the sizing, design and performance of a
potential system, but the user should use this as a guide when using
these results to inform real\sphinxhyphen{}life systems.


\subsection{Getting CLOVER on your computer}
\label{\detokenize{overview:getting-clover-on-your-computer}}

\subsubsection{Downloading CLOVER}
\label{\detokenize{overview:downloading-clover}}
\sphinxAtStartPar
Go to \sphinxurl{https://github.com/phil-sandwell/CLOVER} to download the latest
version of CLOVER by clicking the “Clone or download” button and
selecting “Download ZIP”. This will download a zipped folder containing
all of the files you need to get started.


\subsubsection{CLOVER file structure}
\label{\detokenize{overview:clover-file-structure}}
\sphinxAtStartPar
The file structure from the download has two branches:
\begin{itemize}
\item {} 
\sphinxAtStartPar
a \sphinxstyleemphasis{Scripts} branch which contains Python files that the user runs and uses to generate outputs and perform simulations and optimisations,

\item {} 
\sphinxAtStartPar
a \sphinxstyleemphasis{Locations} branch that describes individual locations and the specifics of a given scenario being investigated.

\end{itemize}

\sphinxAtStartPar
An example location, \sphinxstyleemphasis{Bahraich} in India, is included in the initial
download for reference. New locations can be set up using the generic
\sphinxstyleemphasis{New\_Location} folder structure. It is recommended that the user makes a
copy of the entire \sphinxstyleemphasis{New\_Location} folder and renames it as their
location to ensure that all of the necessary files are included.


\subsubsection{CLOVER modules}
\label{\detokenize{overview:clover-modules}}
\sphinxAtStartPar
CLOVER is designed to be modular, with each module or script performing
a specific function (e.g. calculating the load of a community, getting
the solar generation, or simulating the performance of a system). Each
module can be run independently and some modules use (\sphinxstyleemphasis{import}) others
to use as an input, for example the \sphinxstyleemphasis{Optimisation} module uses the
\sphinxstyleemphasis{Energy\_System}, which in turn uses the \sphinxstyleemphasis{Solar} module.


\subsubsection{Running CLOVER}
\label{\detokenize{overview:running-clover}}
\sphinxAtStartPar
The recommended integrated development environment (IDE) for running
CLOVER is \sphinxhref{https://www.spyder-ide.org}{Spyder} although many others
are available. This IDE is software which allows the user to view and
edit scripts, run the code, run individual functions, and view the
outputs easily. The easiest way to get Spyder is to download
\sphinxhref{https://www.anaconda.com/distribution}{Anaconda} which includes
Spyder as a default package. CLOVER is written using Python 3 so the
user should make sure that their Python environment uses this version;
the packages that CLOVER uses are all included in the Anaconda
distribution.


\subsection{About this guide}
\label{\detokenize{overview:about-this-guide}}
\sphinxAtStartPar
This document is designed to guide a new user from the point of
downloading CLOVER to being able to run their own simulations and
optimisations. It contains worked examples of using the code and, owing
to the format of the document, several pieces of code are included in
this document which will not be necessary when running CLOVER using
Spyder. These include viewing the input CSV files (which can be done in
your file browser) and executing the code (which can be done by clicking
the green arrow in Spyder) but are necessary to compile the code here.
These will be highlighted as they come up.

\sphinxAtStartPar
Throughout this guide the \sphinxstylestrong{text in bold} highlights the steps you need
to take to set up CLOVER, \sphinxstyleemphasis{text in italics} refers to the names of
modules or other parts of the model structure, and \sphinxcode{\sphinxupquote{text in code}}
refers to variables or functions.


\section{General setup}
\label{\detokenize{general_setup:general-setup}}\label{\detokenize{general_setup::doc}}

\subsection{Setting up CLOVER}
\label{\detokenize{general_setup:setting-up-clover}}
\sphinxAtStartPar
Once you have downloaded CLOVER you will need to set up the code to run
on your machine. You may need to install Anaconda and/or Spyder
(\sphinxhref{https://www.anaconda.com/distribution/}{available here}) in order
to run the code if you have not used Python in the past.

\sphinxAtStartPar
After the initial download, each script will need to be updated to match
your file path. This means that the modules that use other modules know
where to look when accessing them, otherwise they will give an error.
The scripts will also need to be updated to match the location you are
investigating, although throughout this guide we will use Bahraich as
the example location as all of the input data is provided in the CLOVER
download.


\subsubsection{Dependencies}
\label{\detokenize{general_setup:dependencies}}
\sphinxAtStartPar
CLOVER relies on the following packages so please ensure you have them
installed:
\begin{itemize}
\item {} 
\sphinxAtStartPar
pandas

\item {} 
\sphinxAtStartPar
numpy

\item {} 
\sphinxAtStartPar
scipy

\item {} 
\sphinxAtStartPar
math

\item {} 
\sphinxAtStartPar
requests

\item {} 
\sphinxAtStartPar
json

\item {} 
\sphinxAtStartPar
random

\item {} 
\sphinxAtStartPar
datetime

\end{itemize}


\subsubsection{Updating the file path and location}
\label{\detokenize{general_setup:updating-the-file-path-and-location}}
\sphinxAtStartPar
Each module (Python file, with a \sphinxcode{\sphinxupquote{.py}} appendix) in the \sphinxstyleemphasis{Scripts}
branch has a line in the initial definition function which sets the
filepath of your CLOVER software and the location you are investigating.
It looks something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{location} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bahraich}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{CLOVER\PYGZus{}filepath} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/***YOUR LOCAL FILE PATH***/CLOVER 4.0}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Our chosen location is Bahraich, so we do not need to update
\sphinxstyleemphasis{self.location}, but we do need to input our file path. In my case this
is saved in my documents (\sphinxcode{\sphinxupquote{Users/prs09}}) in a folder called \sphinxstyleemphasis{CLOVER},
so the entire file path (\sphinxcode{\sphinxupquote{Users/prs09/CLOVER}}) needs to be inserted
here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{CLOVER\PYGZus{}filepath} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/Users/prs09/CLOVER}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Some modules contain the filepath in several places so make sure to
update all of them in each file. \sphinxstylestrong{Repeat this for all of the modules in
the scripts folder so that they are all ready to use.}


\subsubsection{Troubleshooting}
\label{\detokenize{general_setup:troubleshooting}}
\sphinxAtStartPar
If you have issues when updating the file paths or locations, check the
following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Your file path contains a complete list of the folders where your CLOVER folder is saved

\item {} 
\sphinxAtStartPar
You use the correct syntax for your operating system (e.g. “/” vs. “\textbackslash{}” when stating the file path)

\item {} 
\sphinxAtStartPar
You have not added or removed slashes from the end of the file path

\item {} 
\sphinxAtStartPar
You have used the correct quotation marks, and they match (e.g. “double” or ‘single’ quotation marks, not \textasciigrave{}grave accent\textasciigrave{})

\end{itemize}


\subsection{Setting up a location}
\label{\detokenize{general_setup:setting-up-a-location}}

\subsubsection{Make a new location}
\label{\detokenize{general_setup:make-a-new-location}}
\sphinxAtStartPar
Every location will require its own input files for the local
generation, load demand and other factors. The easiest way to make a new
location is to \sphinxstylestrong{copy the New\_Location folder in the Locations folder
and rename it as your chosen location}. This ensures that your folder
structure is correctly set up, and maintains a copy of the generic
folder in case you want to add a new location in the future.

\sphinxAtStartPar
In this guide we will use the default example location, \sphinxstyleemphasis{Bahraich},
which is a rural district in the state of Uttar Pradesh in northern
India.


\subsubsection{Get a \sphinxstyleemphasis{Renewables.ninja} API token}
\label{\detokenize{general_setup:get-a-renewables-ninja-api-token}}
\sphinxAtStartPar
The \sphinxstyleemphasis{Solar} module gets solar generation data from another model
developed at Imperial College London called \sphinxstyleemphasis{Renewables.ninja} which can
provide renewables generation data for any location in the world at an
hourly resolution and over several years. CLOVER automatically
interfaces with the \sphinxstyleemphasis{Renewables.ninja} web interface but to do so you
will need to \sphinxhref{https://www.renewables.ninja/register}{register for an account at
https://www.renewables.ninja/register}\sphinxstylestrong{, and
use the API token in your version of CLOVER.} This is found in the
“Profile” section of your \sphinxstyleemphasis{Renewables.ninja} account. More information
about the API is available in the “Documentation” page on the website.


\subsubsection{Establish your location}
\label{\detokenize{general_setup:establish-your-location}}
\sphinxAtStartPar
First you will need to provide details of the geographic location being
investigated. These are contained in the \sphinxstyleemphasis{Location inputs} file in the
\sphinxstyleemphasis{Location data} folder. You can edit these in the CSV file directly, but
here we will import the data and print it to the screen to see the input
data for Bahraich:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import pandas as pd
location\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Location Data/Location inputs.csv\PYGZdq{})
location\PYGZus{}inputs.head(len(location\PYGZus{}inputs)\PYGZhy{}1)
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
Some of these variables should be self\sphinxhyphen{}explanatory: the location
\sphinxstyleemphasis{Bahraich} is located in \sphinxstyleemphasis{India}. Others are less obvious: the time
period under consideration has a maximum of 20 years (it can be less
than this, but not more without modifying the code, so it is best to
leave this as it is). Here we assume there are 100 households in the
community with a household growth rate of 1\% per year (0.01, expressed
as a fraction). This is also where the \sphinxstyleemphasis{Renewables.ninja} API token
should be copied so that other parts CLOVER can use it later \sphinxhyphen{} as this
is private I have not displayed mine in the table above.

\sphinxAtStartPar
Some are sensitive to positive or negative values, for example the time
difference of India compared to UTC is +5:30 and so the input is 5.5,
but countries west of UTC should use negative time differences
(e.g. Honduras would be \sphinxhyphen{}6). Latitude and longitude are defined as North
and East being positive and expressed as decimals; these are easily
obtainable from Google Maps, for example.


\section{Electricity generation}
\label{\detokenize{electricity_generation:electricity-generation}}\label{\detokenize{electricity_generation::doc}}
\sphinxAtStartPar
This section provides an overview of how to set up the electricity
generation in CLOVER using its three modules solar, diesel and the
national grid network. Further modules with new technologies could be
added in the future to increase its functionality.


\subsection{Solar}
\label{\detokenize{electricity_generation:solar}}

\subsubsection{Preparation}
\label{\detokenize{electricity_generation:preparation}}
\sphinxAtStartPar
The \sphinxstyleemphasis{Solar} module allows the user to get solar generation data for
their location using the \sphinxstyleemphasis{Renewables.ninja} interface. Because this
module relies on this external source of data it acts differently from
other CLOVER modules, but ultimately returns the format of data that we
expect from all of the generation files.

\sphinxAtStartPar
First, \sphinxstylestrong{complete the “PV generation inputs” CSV file in the PV
folder}, which itself is located in the \sphinxstyleemphasis{Generation} folder. Let’s take
a look at the inputs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import pandas as pd
solar\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Generation/PV/PV generation inputs.csv\PYGZdq{},header=None)
solar\PYGZus{}inputs.head(len(solar\PYGZus{}inputs))
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
These should all be straightforward: we assume our panels are
south\sphinxhyphen{}facing (180\(^{\circ}\) from North) and has a lifetime of 20
years, typical for a solar panel and used by CLOVER to account for
module degradation. We also have stated that our panels will have a tilt
(or elevation) of 29\(^{\circ}\) above the horizontal, or make a
29\(^{\circ}\) angle compared to flat ground (which would be
0\(^{\circ}\)). This angle could (for example) be the tilt of a
roof that the panels are assumed to be located on, or it could be the
optimum angle that maximises total energy generation over the course of
a year (which can be found using the \sphinxstyleemphasis{Renewables.ninja} web interface,
or many other programmes).


\subsubsection{Getting solar generation}
\label{\detokenize{electricity_generation:getting-solar-generation}}
\sphinxAtStartPar
Our goal is to get 20 years of solar generation data for our location at
an hourly resolution. The data will be the output energy of one
functional unit of nominal power of the PV for each hour of the year,
assuming it is installed at the specified location and orientation. The
functional unit of nominal power (also called the nameplate capacity) is
the kilowatt\sphinxhyphen{}peak (kWp), defined to be instantaneous power output of a
PV array under standard test conditions (1000 W/m\(^2\)). This
value is most commonly reported when buying solar modules, for example a
panel with a nominal power (or nameplate capacity) of 300 Wp (0.3 kWp)
would provide 300 W of power when illuminated under standard test
conditions, or have a higher output if the illumination were higher (and
vice versa). The actual power received from a module of a given capacity
depends on many factors, for example the amount of illumination on the
panel and the losses from a variety of sources, but \sphinxstyleemphasis{Renewables.ninja}
calculates these automatically for us.

\sphinxAtStartPar
Using this functional unit makes it easy to scale up the generation
capacity to the desired amount in a simulated system. First, check that
you have already updated the location and filepaths of the \sphinxstyleemphasis{Solar}
module and \sphinxstylestrong{run the script (using the green arrow in the Spyder
console)}. Here we run it like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import sys
sys.path.insert(0, \PYGZsq{}/Users/prs09/Documents/CLOVER/Scripts/Generation scripts/\PYGZsq{})
from Solar import Solar
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxstyleemphasis{Solar} module contains several nested functions which automatically
provide a step\sphinxhyphen{}by\sphinxhyphen{}step process to send data to \sphinxstyleemphasis{Renewables.ninja} about
the system parameters, account for the orientation of the system, and
return ready\sphinxhyphen{}to\sphinxhyphen{}use data. We want to get 20 years of solar data but
unfortunately the archives do not go back that far, so instead we will
get 10 years of data and repeat it: this will allow us to keep the
year\sphinxhyphen{}on\sphinxhyphen{}year variation whilst also covering our entire desired time
period.

\sphinxAtStartPar
To do this we run a function which gets one year of solar generation and
repeat the process until we have 10 years. In the Bahraich example we
have data from 2007 to 2016, so let’s replicate this. First we will
generate the data for 2007 by running the following function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Solar().save\PYGZus{}solar\PYGZus{}output(gen\PYGZus{}year = 2007)
\end{sphinxVerbatim}

\sphinxAtStartPar
This automatically saves a CSV file for us, and we can look at the first
day’s worth of entries:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
solar\PYGZus{}generation\PYGZus{}2007 = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Generation/PV/solar\PYGZus{}generation\PYGZus{}2007.csv\PYGZdq{},header=None)
solar\PYGZus{}generation\PYGZus{}2007.columns = [\PYGZsq{}Hour\PYGZsq{},\PYGZsq{}kW\PYGZsq{}]
print(solar\PYGZus{}generation\PYGZus{}2007[0:24])
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Hour}     \PYG{n}{kW}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{1}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{2}      \PYG{l+m+mi}{2}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{3}      \PYG{l+m+mi}{3}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{4}      \PYG{l+m+mi}{4}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{5}      \PYG{l+m+mi}{5}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{6}      \PYG{l+m+mi}{6}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{7}      \PYG{l+m+mi}{7}  \PYG{l+m+mf}{0.009}
\PYG{l+m+mi}{8}      \PYG{l+m+mi}{8}  \PYG{l+m+mf}{0.184}
\PYG{l+m+mi}{9}      \PYG{l+m+mi}{9}  \PYG{l+m+mf}{0.419}
\PYG{l+m+mi}{10}    \PYG{l+m+mi}{10}  \PYG{l+m+mf}{0.591}
\PYG{l+m+mi}{11}    \PYG{l+m+mi}{11}  \PYG{l+m+mf}{0.687}
\PYG{l+m+mi}{12}    \PYG{l+m+mi}{12}  \PYG{l+m+mf}{0.733}
\PYG{l+m+mi}{13}    \PYG{l+m+mi}{13}  \PYG{l+m+mf}{0.697}
\PYG{l+m+mi}{14}    \PYG{l+m+mi}{14}  \PYG{l+m+mf}{0.594}
\PYG{l+m+mi}{15}    \PYG{l+m+mi}{15}  \PYG{l+m+mf}{0.417}
\PYG{l+m+mi}{16}    \PYG{l+m+mi}{16}  \PYG{l+m+mf}{0.192}
\PYG{l+m+mi}{17}    \PYG{l+m+mi}{17}  \PYG{l+m+mf}{0.017}
\PYG{l+m+mi}{18}    \PYG{l+m+mi}{18}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{19}    \PYG{l+m+mi}{19}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{20}    \PYG{l+m+mi}{20}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{21}    \PYG{l+m+mi}{21}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{22}    \PYG{l+m+mi}{22}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{23}    \PYG{l+m+mi}{23}  \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
As expected, we start getting solar generation from 6:00 (note that
Python begins counting from 0, so the hours of the day run from 0 to 23)
which peaks in the middle of the day and finishes by 17:00.

\sphinxAtStartPar
We then run the same function for the following nine years:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Solar}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{save\PYGZus{}solar\PYGZus{}output}\PYG{p}{(}\PYG{n}{gen\PYGZus{}year} \PYG{o}{=} \PYG{l+m+mi}{2008}\PYG{p}{)}
\PYG{n}{Solar}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{save\PYGZus{}solar\PYGZus{}output}\PYG{p}{(}\PYG{n}{gen\PYGZus{}year} \PYG{o}{=} \PYG{l+m+mi}{2009}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{Solar}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{save\PYGZus{}solar\PYGZus{}output}\PYG{p}{(}\PYG{n}{gen\PYGZus{}year} \PYG{o}{=} \PYG{l+m+mi}{2016}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Until we have 10 years of data. Now we can compile the data together
using a function that stitches the data together in order, from the
starting year of 2007, then repeats it to give the full 20 years of
generation data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Solar().total\PYGZus{}solar\PYGZus{}output(start\PYGZus{}year = 2007)
\end{sphinxVerbatim}

\sphinxAtStartPar
This file contains the total solar generation expected for the 1 kWp
unit panel over the course of 20 years, which is what we aimed to
achieve. This is the file that is imported in the \sphinxstyleemphasis{Energy\_System} module
and used to calculate the total PV generation in a system. \sphinxstylestrong{Use this
process to generate solar data for your location.}


\subsubsection{Extension and visualisation}
\label{\detokenize{electricity_generation:extension-and-visualisation}}
\sphinxAtStartPar
For interest, let’s see its cumulative generation over its lifetime,
rounded to the nearest kWh:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import numpy as np
solar\PYGZus{}generation\PYGZus{}lifetime = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Generation/PV/solar\PYGZus{}generation\PYGZus{}20\PYGZus{}years.csv\PYGZdq{})
total\PYGZus{}generation = np.round(np.sum(solar\PYGZus{}generation\PYGZus{}lifetime[\PYGZsq{}0.0\PYGZsq{}]))
print(\PYGZsq{}Cumulative generation: \PYGZsq{} + str(total\PYGZus{}generation)+\PYGZsq{} kWh\PYGZsq{})
print(\PYGZsq{}Average generation: \PYGZsq{}+str(round(total\PYGZus{}generation/(20*365)))+\PYGZsq{} kWh per day\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Cumulative} \PYG{n}{generation}\PYG{p}{:} \PYG{l+m+mf}{36655.0} \PYG{n}{kWh}
\PYG{n}{Average} \PYG{n}{generation}\PYG{p}{:} \PYG{l+m+mf}{5.0} \PYG{n}{kWh} \PYG{n}{per} \PYG{n}{day}
\end{sphinxVerbatim}

\sphinxAtStartPar
This panel is expected to produce 36.7 MWh of energy over its lifetime,
or around 5.0 kWh of energy per day \sphinxhyphen{} this is reasonable given the
location of the panel in a relatively sunny location in India.

\sphinxAtStartPar
We can quickly visualise its generation over the course of the first
year of its lifetime by taking the first 8760 hours (24 hours times 365
days) and plotting this as a heatmap:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
solar\PYGZus{}gen\PYGZus{}year = solar\PYGZus{}generation\PYGZus{}lifetime.iloc[0:8760][\PYGZsq{}0.0\PYGZsq{}]
solar\PYGZus{}gen\PYGZus{}year = np.reshape(solar\PYGZus{}gen\PYGZus{}year.values,(365,24))

import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib as mpl

\PYGZpc{}matplotlib inline
mpl.rcParams[\PYGZsq{}figure.dpi\PYGZsq{}] = 300

g = sns.heatmap(solar\PYGZus{}gen\PYGZus{}year,
                       vmin = 0.0, vmax = 1.0,
                       cmap = \PYGZsq{}Blues\PYGZsq{}, cbar\PYGZus{}kws = \PYGZob{}\PYGZsq{}label\PYGZsq{}:\PYGZsq{}Power output (kW)\PYGZsq{}\PYGZcb{})
g.set(xticks = range(0,24,2), xticklabels = range(0,24,2),
      yticks = range(0,365,30), yticklabels = range(0,365,30),
      xlabel = \PYGZsq{}Hour of day\PYGZsq{}, ylabel = \PYGZsq{}Day of year\PYGZsq{},
      title = \PYGZsq{}Output of 1 kWp of solar capacity\PYGZsq{})
plt.xticks(rotation = 0)
plt.tight\PYGZus{}layout()
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_13_0}.png}

\sphinxAtStartPar
As we might expect, the solar output varies throughout the year with
longer periods of generation during the summer months. Some days have
far less generation, potentially due to cloudy conditions. We can also
see the total daily generation over the course of the year by taking the
sum of the reshaped \sphinxcode{\sphinxupquote{solar\_gen\_year}} object and plotting the result:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
solar\PYGZus{}daily\PYGZus{}sums = pd.DataFrame(np.sum(solar\PYGZus{}gen\PYGZus{}year,axis=1))
plt.plot(range(365),solar\PYGZus{}daily\PYGZus{}sums)
plt.xticks(range(0,365,30))
plt.yticks(range(0,9,2))
plt.xlabel(\PYGZsq{}Day of year\PYGZsq{})
plt.ylabel(\PYGZsq{}Energy generation (kWh per day)\PYGZsq{})
plt.title(\PYGZsq{}Daily energy generation of 1 kWp of solar capacity\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_15_0}.png}


\subsubsection{Troubleshooting}
\label{\detokenize{electricity_generation:troubleshooting}}
\sphinxAtStartPar
The reason why we need to import the data from \sphinxstyleemphasis{Renewables.ninja}
manually is because the API will flag multiple repeated requests to its
servers and deny access. This makes it not possible to put the
\sphinxcode{\sphinxupquote{Solar().save\_solar\_output(gen\_year)}} function into a for loop for
convenience, as the code will be executed faster than that which the API
will allow. This will also apply if you manually run the function too
quickly, so if you receive an error message relating to the API then
wait for around one minute and try again.

\sphinxAtStartPar
Periodically the \sphinxstyleemphasis{Renewables.ninja} changes its API settings which
affects the way that the \sphinxstyleemphasis{Solar} module interacts with the website. This
requires the CLOVER code to be updated, so if you identify this
happening please email \sphinxhref{mailto:philip.sandwell@gmail.com}{Philip
Sandwell}.


\subsection{Grid}
\label{\detokenize{electricity_generation:grid}}

\subsubsection{Preparation}
\label{\detokenize{electricity_generation:id1}}
\sphinxAtStartPar
The \sphinxstyleemphasis{Grid} module simulates the availability of the national grid
network at the location, particularly when the grid is unreliable or has
variable availability throughout the day. CLOVER assumes that when the
grid is available it can provide an unlimited amount of power to satisfy
the needs of the community for the entire hour in question or, if
unavailable, no power can be drawn from it. The goal of the \sphinxstyleemphasis{Grid}
module is to provide an hourly profile of whether the grid is available
or not by using a user\sphinxhyphen{}specified availability profile (or several of
them, if many are to be investigated).

\sphinxAtStartPar
First, \sphinxstylestrong{complete the “Grid inputs” CSV file} in the \sphinxstyleemphasis{Grid} folder,
which itself is located in the \sphinxstyleemphasis{Generation} folder. Let’s take a look at
the inputs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
grid\PYGZus{}times = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Generation/Grid/Grid inputs.csv\PYGZdq{},header=0)
print(grid\PYGZus{}times)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Name}  \PYG{n}{none}  \PYG{n+nb}{all}  \PYG{n}{daytime}  \PYG{n}{eight\PYGZus{}hours}  \PYG{n}{bahraich}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.57}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{1}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.61}
\PYG{l+m+mi}{2}      \PYG{l+m+mi}{2}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.54}
\PYG{l+m+mi}{3}      \PYG{l+m+mi}{3}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.50}
\PYG{l+m+mi}{4}      \PYG{l+m+mi}{4}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.48}
\PYG{l+m+mi}{5}      \PYG{l+m+mi}{5}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.48}
\PYG{l+m+mi}{6}      \PYG{l+m+mi}{6}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.46}
\PYG{l+m+mi}{7}      \PYG{l+m+mi}{7}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.34}
\PYG{l+m+mi}{8}      \PYG{l+m+mi}{8}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.25}
\PYG{l+m+mi}{9}      \PYG{l+m+mi}{9}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.30}
\PYG{l+m+mi}{10}    \PYG{l+m+mi}{10}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.35}
\PYG{l+m+mi}{11}    \PYG{l+m+mi}{11}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.35}
\PYG{l+m+mi}{12}    \PYG{l+m+mi}{12}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.33}
\PYG{l+m+mi}{13}    \PYG{l+m+mi}{13}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.29}
\PYG{l+m+mi}{14}    \PYG{l+m+mi}{14}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.32}
\PYG{l+m+mi}{15}    \PYG{l+m+mi}{15}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.35}
\PYG{l+m+mi}{16}    \PYG{l+m+mi}{16}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.35}
\PYG{l+m+mi}{17}    \PYG{l+m+mi}{17}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.32}
\PYG{l+m+mi}{18}    \PYG{l+m+mi}{18}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{19}    \PYG{l+m+mi}{19}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.14}
\PYG{l+m+mi}{20}    \PYG{l+m+mi}{20}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.18}
\PYG{l+m+mi}{21}    \PYG{l+m+mi}{21}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.46}
\PYG{l+m+mi}{22}    \PYG{l+m+mi}{22}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.47}
\PYG{l+m+mi}{23}    \PYG{l+m+mi}{23}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}        \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.33}      \PYG{l+m+mf}{0.51}
\end{sphinxVerbatim}

\sphinxAtStartPar
This file describes five grid availability profiles, with each of the
values corresponding to the probability that the grid will be available
in the hour of the day specified on the left. Taking the sum of those
values will give the average number of hours per day that the grid will
be available. The profiles we have here are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{none}} has no grid availability at all throughout the day, equivalent to not being connected to the grid

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{all}} has full grid availability at all times

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{daytime}} has grid availability throughout the day (8:00 until 17:59) but never at night

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eight\_hours}} will provide approximately eight hours of power, randomly available throughout the day

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bahraich}} is an example profile from data gathered from Bahraich district, where availability is higher in the early morning and late evening but lower during the daty and early evening.

\end{itemize}

\sphinxAtStartPar
You can add further grid profiles by adding additional columns in the
CSV file; they can have any name and values for grid availability must
be in the range 0\sphinxhyphen{}1 as they represent probabilities. Save this file before
moving on.


\subsubsection{Getting grid availability profiles}
\label{\detokenize{electricity_generation:getting-grid-availability-profiles}}
\sphinxAtStartPar
Our goal is to get 20 years of grid availability data at an hourly
resolution, represented as 0s (grid is unavailable) and 1s (grid is
available), for each of the grid profiles listed in \sphinxstyleemphasis{Grid inputs}.

\sphinxAtStartPar
First, check that you have already updated the location and filepaths of
the \sphinxstyleemphasis{Grid} module and \sphinxstylestrong{run the script (using the green arrow in the
Spyder console)}. Here we run it like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
from Grid import Grid
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxstyleemphasis{Grid} module is quite straightforward as it uses a single function
to take an input grid profile, repeats the probability profile over a 20
year period, uses binomial statistics to transsform them into a profile
of 0s and 1s, and save this availability as a new output CSV file to use
later. To do this for all of the grid profiles \sphinxstylestrong{run the following
function} in your console:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Grid}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}lifetime\PYGZus{}grid\PYGZus{}status}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once this function is completed your new grid profiles will appear in
your \sphinxstyleemphasis{Grid} folder and be ready to use, with their file names
corresponding to the name of the status given in the input file (e.g.
\sphinxcode{\sphinxupquote{eight\_hours\_grid\_status.csv}}). Given the nature of the calculation,
this function will take a while to complete. This is normal and
fortunately this process needs to be completed only once: the same grid
availability profiles can be used in each of your investigations for
reproducibility.


\subsubsection{Extension and visualisation}
\label{\detokenize{electricity_generation:id2}}
\sphinxAtStartPar
Let’s take a closer look the \sphinxcode{\sphinxupquote{bahraich}} grid profile by seeing how
many hours per day it is available on average:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bahraich\PYGZus{}daily\PYGZus{}hours = np.sum(grid\PYGZus{}times[\PYGZsq{}bahraich\PYGZsq{}],axis=0)
print(str(bahraich\PYGZus{}daily\PYGZus{}hours) + \PYGZsq{} hours per day\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{9.34} \PYG{n}{hours} \PYG{n}{per} \PYG{n}{day}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{bahraich}} profile gives an average of 9.34 hours of availability
per day, relatively normal for that region of rural India but definitely
has potential to be improved by installing a minigrid system. Now let’s
plot the grid availability throughout the day

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plt.plot(range(24),grid\PYGZus{}times[\PYGZsq{}bahraich\PYGZsq{}],color=\PYGZsq{}k\PYGZsq{})
plt.xticks(range(0,24,2))
plt.yticks(np.arange(0,1.1,0.2))
plt.xlabel(\PYGZsq{}Hour of day\PYGZsq{})
plt.ylabel(\PYGZsq{}Probability\PYGZsq{})
plt.title(\PYGZsq{}Probability of grid electricity being available\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_24_0}.png}

\sphinxAtStartPar
As we saw before, the grid is most likely to be available in the early
morning and least likely to be available in the evening. We can also
investigate the \sphinxcode{\sphinxupquote{bahraich}} grid availability profile that we made
using \sphinxcode{\sphinxupquote{Grid().get\_lifetime\_grid\_status()}}, for example by viewing
whether the grid is available or not over the first year. Here we plot
it using a colour scheme of white meaning the grid is available, or
black when it is not (i.e. a blackout):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bahraich\PYGZus{}profile = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Generation/Grid/bahraich\PYGZus{}grid\PYGZus{}status.csv\PYGZdq{})
bahraich\PYGZus{}profile = bahraich\PYGZus{}profile.iloc[0:8760][\PYGZsq{}0\PYGZsq{}]
bahraich\PYGZus{}profile = np.reshape(bahraich\PYGZus{}profile.values,(365,24))

g = sns.heatmap(bahraich\PYGZus{}profile,
                vmin = 0.0, vmax = 1.0,
                cmap = \PYGZsq{}Greys\PYGZus{}r\PYGZsq{}, cbar=False)
g.set(xticks = range(0,24,2), xticklabels = range(0,24,2),
      yticks = range(0,365,30), yticklabels = range(0,365,30),
      xlabel = \PYGZsq{}Hour of day\PYGZsq{}, ylabel = \PYGZsq{}Day of year\PYGZsq{},
      title = \PYGZsq{}Grid availability of the Bahraich profile\PYGZsq{})
plt.xticks(rotation = 0)
plt.tight\PYGZus{}layout()
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_26_0}.png}

\sphinxAtStartPar
We can once again see the expected structure from the one\sphinxhyphen{}day
availability input profile, but now with the randomness of day\sphinxhyphen{}to\sphinxhyphen{}day
variations. There is greater availability in the mornings, but not
always, and only on a very small number of days is power available
between 19:00 and 21:00.

\sphinxAtStartPar
We can also compare the \sphinxcode{\sphinxupquote{bahraich}} input profile to the synthesised
availability profile to make sure they match up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plt.plot(range(24),grid\PYGZus{}times[\PYGZsq{}bahraich\PYGZsq{}],color=\PYGZsq{}k\PYGZsq{},label=\PYGZsq{}Input\PYGZsq{})
plt.plot(range(24),np.mean(bahraich\PYGZus{}profile,axis=0),color=\PYGZsq{}r\PYGZsq{},label=\PYGZsq{}Output\PYGZsq{})
plt.legend()
plt.xticks(range(0,24,2))
plt.yticks(np.arange(0,1.1,0.2))
plt.xlabel(\PYGZsq{}Hour of day\PYGZsq{})
plt.ylabel(\PYGZsq{}Probability\PYGZsq{})
plt.title(\PYGZsq{}Probability of grid electricity being available\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_28_0}.png}

\sphinxAtStartPar
As we should expect, the output profile matches the input profile
closely, but not exactly, owing to the random process that was used to
generate it.


\subsubsection{Troubleshooting}
\label{\detokenize{electricity_generation:id3}}
\sphinxAtStartPar
Rerunning the \sphinxcode{\sphinxupquote{Grid().get\_lifetime\_grid\_status()}} function will create
new profiles: these will share the same statistics as a previously
generated grid status but not be exactly the same. If you want to
generate a new grid status but also want to keep ones you have already
generated, it is recommended that you save your original files in
another location and copy them back to the \sphinxstyleemphasis{Grid} folder once your new
profile is complete.

\sphinxAtStartPar
CLOVER has the functionality to create grid profiles with variation
throughout the day, but not throughout the year. If you want to include
this, create an availability profile in a compatible format (20 years of
hourly data, composed of 0s and 1s) using some other means, name it
using the\sphinxcode{\sphinxupquote{{[}name{]}\_grid\_status.csv}} format, and copy this CSV file to
the \sphinxstyleemphasis{Grid} folder. CLOVER should be able to use this CSV file as an
input later, the same as any others that it generates.


\subsection{Diesel}
\label{\detokenize{electricity_generation:diesel}}

\subsubsection{Preparation}
\label{\detokenize{electricity_generation:id4}}
\sphinxAtStartPar
The \sphinxstyleemphasis{Diesel} module is a passive script, meaning that the user needs to
provide it with inputs but not actively run any of its functions (CLOVER
does this automatically instead). In the current release of CLOVER
diesel generation is treated as a backup source of power when the other
sources are unable to provide electricity, filling in periods of
blackouts after a simulation is complete to provide greater levels of
reliability. This means it can be used as a backup source of power in a
hybrid system (for example switching on automatically when renewable
generation is not sufficient) but not as dispatchable generation coming
on at user\sphinxhyphen{}specified times. This functionality will be included in the
next update of CLOVER.

\sphinxAtStartPar
First, \sphinxstylestrong{complete the “Diesel inputs” CSV file} in the \sphinxstyleemphasis{Diesel}
folder, which itself is located in the \sphinxstyleemphasis{Generation} folder. Let’s take a
look at the inputs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
diesel\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Generation/Diesel/Diesel inputs.csv\PYGZdq{})
print(diesel\PYGZus{}inputs)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Diesel} \PYG{n}{consumption}   \PYG{l+m+mf}{0.4}    \PYG{n}{litres} \PYG{n}{per} \PYG{n}{kW} \PYG{n}{capacity} \PYG{n}{per} \PYG{n}{hour}
\PYG{l+m+mi}{0}  \PYG{n}{Diesel} \PYG{n}{minimum} \PYG{n}{load}  \PYG{l+m+mf}{0.35}  \PYG{n}{Minimum} \PYG{n}{capacity} \PYG{n}{factor} \PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This input file contains just two variables but more parameters
governing the usage of the diesel generator are included elsewhere.
\sphinxcode{\sphinxupquote{Diesel consumption}} refers to the hourly fuel consumption of the
generator per kW of output, for example a generator providing 10 kW
would use 4.0 litres of fuel per hour. CLOVER assumes that this fuel
consumption is constant per kW of power being supplied, although in real
systems diesel generators may have varying efficiencies dependent on the
load factor.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel minimum load}} is the lowest load factor that the generator is
permitted to operate at (for example to avoid mechanical issues or
degradation), expressed as a fraction. For example, a 5 kW generator
would be forced to provide at least 1.75 kW (5.0 kW x 0.35) of power to
ensure it runs above the minimum load factor even if the load were less
than this, with the remaining energy being dumped.


\subsubsection{Getting diesel generation}
\label{\detokenize{electricity_generation:getting-diesel-generation}}
\sphinxAtStartPar
As mentioned above, as a passive script CLOVER uses the \sphinxstyleemphasis{Diesel} module
automatically so the user does not need to run any of its functions.
Nevertheless it is good practice to ensure that the script runs as
expected, so check that you have already updated the location and
filepaths of the \sphinxstyleemphasis{Diesel} module and \sphinxstylestrong{run the script (using the green
arrow in the Spyder console)}. Here we run it like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
from Diesel import Diesel
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the script is ready to be used by the rest of CLOVER.


\section{Load profiles}
\label{\detokenize{load:load-profiles}}\label{\detokenize{load::doc}}
\sphinxAtStartPar
CLOVER has the functionality to build load profiles from the bottom\sphinxhyphen{}up,
summarised in the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Input the devices or appliances available in the community

\item {} 
\sphinxAtStartPar
Input the usage profile of each device throughout the day and year

\item {} 
\sphinxAtStartPar
Calculate the number of devices in use throughout the lifetime of the system

\item {} 
\sphinxAtStartPar
Calculate the daily utilisation profile of each device

\item {} 
\sphinxAtStartPar
Calculate the number of devices in use in every hour

\item {} 
\sphinxAtStartPar
Calculate the load profile of each device

\item {} 
\sphinxAtStartPar
Calculate the total load profile of the community.

\end{enumerate}

\sphinxAtStartPar
This process is performed by the \sphinxstyleemphasis{Load} module, described in this
section. The terms \sphinxstyleemphasis{device} and \sphinxstyleemphasis{appliance} are used interchangeably,
meaning any piece of equipment that uses electricity, and specific
meanings of other similar terms (for example \sphinxstyleemphasis{usage} and \sphinxstyleemphasis{utilisation})
will be made explicit where relevant.


\subsection{Preparation}
\label{\detokenize{load:preparation}}

\subsubsection{Input the devices in the community}
\label{\detokenize{load:input-the-devices-in-the-community}}
\sphinxAtStartPar
CLOVER allows the user to include as many devices as desired in their
load profile. These are input using the \sphinxcode{\sphinxupquote{Devices}} input CSV in the
\sphinxstyleemphasis{Load} folder for the given location, which can be edited directly.
Let’s look at the devices included for Bahraich:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import pandas as pd
devices = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Devices.csv\PYGZdq{})
devices.head(len(devices))
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
This CSV contains many variables, some of which are more obvious than
others, summarised in the table below:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Device}}
&
\sphinxAtStartPar
Unique name of the device
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Available}}
&
\sphinxAtStartPar
Device is included (\sphinxcode{\sphinxupquote{Y}}) or not
(\sphinxcode{\sphinxupquote{N}}) in the community load
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Power}}
&
\sphinxAtStartPar
Device power consumption (W)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Initial}}
&
\sphinxAtStartPar
Average ownership of the device
per household at the start of the
time period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Final}}
&
\sphinxAtStartPar
Average ownership of the device
per household at the end of the
time period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Innovation}}
&
\sphinxAtStartPar
Parameter governing new
households acquiring device
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Imitation}}
&
\sphinxAtStartPar
Parameter governing households
copying others
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Type}}
&
\sphinxAtStartPar
Classification of the device as a
\sphinxcode{\sphinxupquote{Domestic}}, \sphinxcode{\sphinxupquote{Commercial}} or
\sphinxcode{\sphinxupquote{Public}} device
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Take the example of the device \sphinxcode{\sphinxupquote{light}}, which represents an LED bulb.
It is available in the load profile (\sphinxcode{\sphinxupquote{Available = Y}}), has a power
rating of 3 W, and classified as a \sphinxcode{\sphinxupquote{Domestic}} load. At the start of
the simulation period there is an average two LED bulbs per household
(\sphinxcode{\sphinxupquote{Initial = 2.00}}) which, over time, increases to four bulbs per
household (\sphinxcode{\sphinxupquote{Final = 4.00}}) by the end of the considered time period \sphinxhyphen{}
which we defined to be to 20 years in the \sphinxstyleemphasis{General Setup} section.

\sphinxAtStartPar
The two remaining variables describe how quickly the average ownership
per household increases: to generalise, \sphinxcode{\sphinxupquote{Innovation}} describes how
likely a household is to get a new appliance based on how much they like
new things and \sphinxcode{\sphinxupquote{Imitation}} describes how much a household is
influenced by others already having the device. These are inputs into a
model of how quickly devices diffuse throughout the community (described
in more detail later) but, simply put, the larger these numbers the
quicker households will acquire them. These should be treated almost as
qualitative measures: the values for a more desirable appliance like a
television should be higher than (for example) a radio. You can use
later outputs from the \sphinxstyleemphasis{Load} module to check that your appliance
diffusion seems viable.

\sphinxAtStartPar
If you do not want to include any demand growth over time by keeping the
number of appliances the same throughout the simulation, it is possible
to turn off this feature simply by setting the values for \sphinxcode{\sphinxupquote{Initial}}
and \sphinxcode{\sphinxupquote{Final}} to be the same, which will negate the \sphinxcode{\sphinxupquote{Innovation}} and
\sphinxcode{\sphinxupquote{Imitation}} parameters (for example \sphinxcode{\sphinxupquote{streetlight}} does this). Bear
in mind that an increase in the number of households, defined when
establishing the location, will result in an increase in the number of
devices as the latter is calculated on the basis of the number of
devices \sphinxstyleemphasis{per household}.

\sphinxAtStartPar
One of the devices, \sphinxcode{\sphinxupquote{kerosene}}, is different from the others and is
the only device which \sphinxstyleemphasis{must} remain present in the \sphinxstyleemphasis{Devices} file.
CLOVER has the functionality to account for the usage of backup
non\sphinxhyphen{}electric lighting devices, such as kerosene lamps, which are used
during periods when electricity is unavailable. This is useful when
investigating electricity systems with less than 100\% reliability, for
example. \sphinxstylestrong{This device is therefore necessary as an input for later
functions and must be present here, and have corresponding utilisation
profiles}, described later. If backup sources of non\sphinxhyphen{}electric lighting
are not relevant to your investigation, set \sphinxcode{\sphinxupquote{Initial = 0}} and
\sphinxcode{\sphinxupquote{Final = 0}} in the \sphinxstyleemphasis{Devices} file to not consider it whilst still
allowing the other functions to operate as expected. If a different
non\sphinxhyphen{}electric lighting source is relevant, such as candles, complete the
input data for that source but the name must remain as \sphinxcode{\sphinxupquote{kerosene}} in
the \sphinxstyleemphasis{Devices} file.

\sphinxAtStartPar
\sphinxstylestrong{With this in mind, complete the} \sphinxcode{\sphinxupquote{Devices}} \sphinxstylestrong{input CSV for your
investigation.}


\subsubsection{Input the device utilisation profiles}
\label{\detokenize{load:input-the-device-utilisation-profiles}}
\sphinxAtStartPar
CLOVER first considers the service that appliances provide as a
necessary step in understanding the electricity demand of the community,
rather than jumping directly to the latter. This is because two devices
may provide very similar services, and the times of using those devices
may be very similar, but the electricity requirements could be very
different: LED and incandescent light bulbs, for example. By considering
the demand for the service as a first step it is possible to more easily
consider issues such as the usage of efficient, low\sphinxhyphen{}power devices which
are becoming more common.

\sphinxAtStartPar
The \sphinxstyleemphasis{utilisation} of a device is defined to be the probability that a
device is being used, given that it is present in the community.
Utilisation values can vary hourly (throughout the day) and monthly
(throughout the year) and must be between 0 (the device is never used in
a specific hour) to 1 (it is always used). Utilisation profiles for each
device are found in the \sphinxstyleemphasis{Device utilisation} folder in the \sphinxstyleemphasis{Load}
folder.

\sphinxAtStartPar
Every device listed in the \sphinxcode{\sphinxupquote{Devices}} input CSV \sphinxstylestrong{must have a
utilisation profile associated with it} for CLOVER to calculate the
load demand correctly and be named \sphinxcode{\sphinxupquote{{[}device{]}\_times}}. Even if a device
has \sphinxcode{\sphinxupquote{Available = N}} in the \sphinxstyleemphasis{Devices} input CSV, CLOVER will still use
the utilisation profile but not eventually include the load in the final
total community demand. If you do not want to include a device at all it
is much easier to delete its entry from the \sphinxstyleemphasis{Devices} input CSV.

\sphinxAtStartPar
Each utilisation profile is a 24 x 12 matrix of utilisation values,
corresponding to the hour of the day for each month of the year. Let’s
take a look at the example of \sphinxcode{\sphinxupquote{light}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
light\PYGZus{}utilisation = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device utilisation/light\PYGZus{}times.csv\PYGZdq{},header=None)
print(light\PYGZus{}utilisation)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{l+m+mi}{0}     \PYG{l+m+mi}{1}     \PYG{l+m+mi}{2}     \PYG{l+m+mi}{3}     \PYG{l+m+mi}{4}     \PYG{l+m+mi}{5}     \PYG{l+m+mi}{6}     \PYG{l+m+mi}{7}     \PYG{l+m+mi}{8}     \PYG{l+m+mi}{9}     \PYG{l+m+mi}{10}    \PYG{l+m+mi}{11}
\PYG{l+m+mi}{0}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{1}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{2}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{3}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{4}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.48}  \PYG{l+m+mf}{0.56}  \PYG{l+m+mf}{0.46}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{5}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.47}  \PYG{l+m+mf}{0.48}  \PYG{l+m+mf}{0.23}  \PYG{l+m+mf}{0.12}  \PYG{l+m+mf}{0.28}  \PYG{l+m+mf}{0.45}  \PYG{l+m+mf}{0.53}  \PYG{l+m+mf}{0.57}  \PYG{l+m+mf}{0.40}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{6}   \PYG{l+m+mf}{0.58}  \PYG{l+m+mf}{0.48}  \PYG{l+m+mf}{0.22}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.05}  \PYG{l+m+mf}{0.37}  \PYG{l+m+mf}{0.53}
\PYG{l+m+mi}{7}   \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{8}   \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{9}   \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{10}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{11}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{12}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{13}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{14}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{15}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{16}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{17}  \PYG{l+m+mf}{0.47}  \PYG{l+m+mf}{0.08}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.74}  \PYG{l+m+mf}{0.76}
\PYG{l+m+mi}{18}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.54}  \PYG{l+m+mf}{0.51}  \PYG{l+m+mf}{0.23}  \PYG{l+m+mf}{0.03}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.26}  \PYG{l+m+mf}{0.79}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{19}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.90}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{20}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{21}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{22}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}
\PYG{l+m+mi}{23}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}
\end{sphinxVerbatim}

\sphinxAtStartPar
This device, representing an LED bulb from before, has a changing
utilisation profile throughout the day: it is never used during the
middle of the day (utilisation is 0.00), is very likely to be used in
the evenings (up to 0.93), and some lights in the community are likely
to be left on overnight (0.39). The utilisation of this device also
changes throughout the year: in January (month 0) the utilisation at
18:00 is 0.93, but is 0.00 in July (month 6), owing to the changing
times of sunset.

\sphinxAtStartPar
Making a representative utilisation profile will depend significantly on
the specifics of your own investigation. These could come from primary
data collection (indeed, the utilisation profile shown above did) or
from your best estimate of what the demand for service is likely to be.
Bear in mind that the probability that a device being used is an average
over the entire community, so this should represent the utilisation of
an “average” household without considering inter\sphinxhyphen{}household variations.
To model device utilisation as the same throughout the year, use the
same 24\sphinxhyphen{}value column for each of the 12 months.

\sphinxAtStartPar
\sphinxstylestrong{For every device you have listed in the} \sphinxcode{\sphinxupquote{Devices}} \sphinxstylestrong{input CSV,
complete a corresponding utilisation profile matrix and ensure that is
is called} \sphinxcode{\sphinxupquote{{[}device{]}\_times}}.


\subsection{Building load profiles}
\label{\detokenize{load:building-load-profiles}}

\subsubsection{Calculating the number of devices in the community}
\label{\detokenize{load:calculating-the-number-of-devices-in-the-community}}
\sphinxAtStartPar
The next step is to know how many devices there are in the community at
any given time which, when combined with the utilisation profiles, will
then allow us to calculate how many are in use. This step is relatively
straightforward in that it takes information we have already input (into
the \sphinxcode{\sphinxupquote{Devices}} CSV file) and calculates everything for us. It also
accounts for the growing number of devices in the community, if we chose
to use that.

\sphinxAtStartPar
To calculate this automatically for all of the devices listed, \sphinxstylestrong{run the
function}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Load}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}devices\PYGZus{}daily}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
in the console. This will take every device listed and calculate the
number in the community on every day of our 20 year investigation
period, and save them as a CSV file in the \sphinxstyleemphasis{Device ownership} folder in
the \sphinxstyleemphasis{Load} folder with title format of \sphinxcode{\sphinxupquote{{[}device{]}\_daily\_ownership.csv}}.
Let’s take a look at the \sphinxcode{\sphinxupquote{light}} device again and look at the first
and final number of devices in the community:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
light\PYGZus{}ownership = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device ownership/light\PYGZus{}daily\PYGZus{}ownership.csv\PYGZdq{})
initial\PYGZus{}light\PYGZus{}ownership = int(light\PYGZus{}ownership.iloc[0][1])
final\PYGZus{}light\PYGZus{}ownership = int(light\PYGZus{}ownership.iloc[\PYGZhy{}1][1])
print(\PYGZsq{}Initial light ownership = \PYGZsq{}+ str(initial\PYGZus{}light\PYGZus{}ownership))
print(\PYGZsq{}Final light ownership = \PYGZsq{} + str(final\PYGZus{}light\PYGZus{}ownership))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Initial} \PYG{n}{light} \PYG{n}{ownership} \PYG{o}{=} \PYG{l+m+mi}{200}
\PYG{n}{Final} \PYG{n}{light} \PYG{n}{ownership} \PYG{o}{=} \PYG{l+m+mi}{487}
\end{sphinxVerbatim}

\sphinxAtStartPar
The final \sphinxcode{\sphinxupquote{light}} ownership perhaps looks higher than expected, but
when we take into account how much the community has grown it makes
sense:

\sphinxAtStartPar
The slight discrepancy in the two values likely comes from the diffusion
model tending towards (but never quite reaching) the final value of
average ownership and/or rounding errors.


\subsubsection{Calculating the daily utilisation profiles}
\label{\detokenize{load:calculating-the-daily-utilisation-profiles}}
\sphinxAtStartPar
The utilisation profiles input for each device was defined by month but,
if we assigned that utilisation profile for the whole month\sphinxhyphen{}long period,
there would be a sharp transition between each month which would be
unrealistic. To overcome this CLOVER interpolates between the monthly
values to give a smooth transition between every day, meaning that there
are no harsh boundaries where demand suddenly changes. This process is
also performed automatically by CLOVER. \sphinxstylestrong{Run the following function in
the console to calculate this:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Load}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}device\PYGZus{}daily\PYGZus{}profile}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function takes the (monthly) utilisation inputs and converts them
to a daily utilisation input of size 365 x 24 and saves it in the
\sphinxstyleemphasis{Device utilisation} folder in the \sphinxstyleemphasis{Load} folder using the title format
\sphinxcode{\sphinxupquote{{[}device{]}\_daily\_times.csv}}. CLOVER assumes that the values stated in
the monthly utilisation profile apply to the middle day of each month
when interpolating to the daily scale.

\sphinxAtStartPar
As an example, let’s compare the monthly input values for January and
February against the first week of daily values for the \sphinxcode{\sphinxupquote{light}}
device:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
jan\PYGZus{}feb\PYGZus{}inputs = light\PYGZus{}utilisation[light\PYGZus{}utilisation.columns[0:2]]
jan\PYGZus{}feb\PYGZus{}inputs.columns = [\PYGZsq{}Jan\PYGZsq{},\PYGZsq{}Feb\PYGZsq{}]
print(\PYGZsq{}Input values for January and February:\PYGZbs{}n\PYGZsq{})
print(jan\PYGZus{}feb\PYGZus{}inputs)

light\PYGZus{}daily\PYGZus{}utilisation = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device utilisation/light\PYGZus{}daily\PYGZus{}times.csv\PYGZdq{},index\PYGZus{}col=0)
light\PYGZus{}daily\PYGZus{}utilisation = round(light\PYGZus{}daily\PYGZus{}utilisation.iloc[0:7],3)
print(\PYGZsq{}\PYGZbs{}nDaily varying values: \PYGZbs{}n\PYGZsq{})
print(light\PYGZus{}daily\PYGZus{}utilisation.T)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Input} \PYG{n}{values} \PYG{k}{for} \PYG{n}{January} \PYG{o+ow}{and} \PYG{n}{February}\PYG{p}{:}

     \PYG{n}{Jan}   \PYG{n}{Feb}
\PYG{l+m+mi}{0}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{1}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{2}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{3}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{4}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{5}   \PYG{l+m+mf}{0.39}  \PYG{l+m+mf}{0.39}
\PYG{l+m+mi}{6}   \PYG{l+m+mf}{0.58}  \PYG{l+m+mf}{0.48}
\PYG{l+m+mi}{7}   \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{8}   \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{9}   \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{10}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{11}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{12}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{13}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{14}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{15}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{16}  \PYG{l+m+mf}{0.00}  \PYG{l+m+mf}{0.00}
\PYG{l+m+mi}{17}  \PYG{l+m+mf}{0.47}  \PYG{l+m+mf}{0.08}
\PYG{l+m+mi}{18}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{19}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{20}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{21}  \PYG{l+m+mf}{0.93}  \PYG{l+m+mf}{0.93}
\PYG{l+m+mi}{22}  \PYG{l+m+mf}{0.88}  \PYG{l+m+mf}{0.88}
\PYG{l+m+mi}{23}  \PYG{l+m+mf}{0.83}  \PYG{l+m+mf}{0.83}

\PYG{n}{Daily} \PYG{n}{varying} \PYG{n}{values}\PYG{p}{:}

        \PYG{l+m+mi}{0}      \PYG{l+m+mi}{1}      \PYG{l+m+mi}{2}      \PYG{l+m+mi}{3}      \PYG{l+m+mi}{4}      \PYG{l+m+mi}{5}      \PYG{l+m+mi}{6}
\PYG{l+m+mi}{0}   \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}
\PYG{l+m+mi}{1}   \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}
\PYG{l+m+mi}{2}   \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}
\PYG{l+m+mi}{3}   \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}
\PYG{l+m+mi}{4}   \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}
\PYG{l+m+mi}{5}   \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}  \PYG{l+m+mf}{0.390}
\PYG{l+m+mi}{6}   \PYG{l+m+mf}{0.555}  \PYG{l+m+mf}{0.557}  \PYG{l+m+mf}{0.559}  \PYG{l+m+mf}{0.560}  \PYG{l+m+mf}{0.562}  \PYG{l+m+mf}{0.564}  \PYG{l+m+mf}{0.566}
\PYG{l+m+mi}{7}   \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{8}   \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{9}   \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{10}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{11}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{12}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{13}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{14}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{15}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{16}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}  \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{17}  \PYG{l+m+mf}{0.615}  \PYG{l+m+mf}{0.605}  \PYG{l+m+mf}{0.594}  \PYG{l+m+mf}{0.584}  \PYG{l+m+mf}{0.574}  \PYG{l+m+mf}{0.563}  \PYG{l+m+mf}{0.553}
\PYG{l+m+mi}{18}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}
\PYG{l+m+mi}{19}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}
\PYG{l+m+mi}{20}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}
\PYG{l+m+mi}{21}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}  \PYG{l+m+mf}{0.930}
\PYG{l+m+mi}{22}  \PYG{l+m+mf}{0.880}  \PYG{l+m+mf}{0.880}  \PYG{l+m+mf}{0.880}  \PYG{l+m+mf}{0.880}  \PYG{l+m+mf}{0.880}  \PYG{l+m+mf}{0.880}  \PYG{l+m+mf}{0.880}
\PYG{l+m+mi}{23}  \PYG{l+m+mf}{0.830}  \PYG{l+m+mf}{0.830}  \PYG{l+m+mf}{0.830}  \PYG{l+m+mf}{0.830}  \PYG{l+m+mf}{0.830}  \PYG{l+m+mf}{0.830}  \PYG{l+m+mf}{0.830}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the daily utilisation CSV file has a slightly different
structure (days are presented as rows) but we have transposed it here
and rounded to three decimal places for comparability and readability.
The hours where there is a difference between utilisation in January and
February (hours 6 and 17) also vary in the daily profile, whilst the
others remain the same as expected. As mentioned above, note that the
utilisation input for January is not the same as the daily utilisation
on day 0: the former is assumed to be for the middle day of the month in
January, whereas the latter is halfway between the inputs for December
and January. We can check this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
december\PYGZus{}utilisation\PYGZus{}example = light\PYGZus{}utilisation[light\PYGZus{}utilisation.columns[11]][6]
january\PYGZus{}utilisation\PYGZus{}example = light\PYGZus{}utilisation[light\PYGZus{}utilisation.columns[0]][6]
midpoint = round((december\PYGZus{}utilisation\PYGZus{}example + january\PYGZus{}utilisation\PYGZus{}example) / 2.0,3)

print(\PYGZsq{}December utilisation at 6:00: \PYGZsq{} + str(december\PYGZus{}utilisation\PYGZus{}example))
print(\PYGZsq{}January utilisation at 6:00: \PYGZsq{} + str(january\PYGZus{}utilisation\PYGZus{}example))
print(\PYGZsq{}Midpoint utilisation between December and January: \PYGZsq{} + str(midpoint))
print(\PYGZsq{}Day 0 utilisation at 6:00: \PYGZsq{} + str(light\PYGZus{}daily\PYGZus{}utilisation.iloc[0][6]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{December} \PYG{n}{utilisation} \PYG{n}{at} \PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:} \PYG{l+m+mf}{0.53}
\PYG{n}{January} \PYG{n}{utilisation} \PYG{n}{at} \PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:} \PYG{l+m+mf}{0.58}
\PYG{n}{Midpoint} \PYG{n}{utilisation} \PYG{n}{between} \PYG{n}{December} \PYG{o+ow}{and} \PYG{n}{January}\PYG{p}{:} \PYG{l+m+mf}{0.555}
\PYG{n}{Day} \PYG{l+m+mi}{0} \PYG{n}{utilisation} \PYG{n}{at} \PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:} \PYG{l+m+mf}{0.555}
\end{sphinxVerbatim}

\sphinxAtStartPar
As expected, the two values match.


\subsubsection{Calculating the number of devices in use}
\label{\detokenize{load:calculating-the-number-of-devices-in-use}}
\sphinxAtStartPar
Now that we have both the number of devices in the community on a given
day, and the daily utilisation profile of each device, we can calculate
the number of devices that are in use at any given time. CLOVER does
this automatically for each type of device by using a binomial random
number generator: the number of trials is the number of devices, and the
probability is the utilisation value for that hour. To do this, \sphinxstylestrong{run
the following function in the console}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Load}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{devices\PYGZus{}in\PYGZus{}use\PYGZus{}hourly}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function will take a while to complete as it runs through each type
of device and randomly assigns the number in use over the full 20 year
period, and needs to be performed once only. The outputs are saved as
CSV files in the \sphinxstyleemphasis{Devices in use} folder in the \sphinxstyleemphasis{Load} folder, using the
title format \sphinxcode{\sphinxupquote{{[}device{]}\_in\_use.csv}}, so that they can be used as
consistent inputs when used by CLOVER. Note that rerunning this function
will create a new profile which will differ every time because of the
random statistics used to generate it: if you need to rerun this
function but want to keep your previous files, save a copy of them
elsewhere otherwise they will be overwritten.

\sphinxAtStartPar
Let’s consider the \sphinxcode{\sphinxupquote{light}} device over the first three days of its
usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import matplotlib.pyplot as plt
import matplotlib as mpl

light\PYGZus{}in\PYGZus{}use = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Devices in use/light\PYGZus{}in\PYGZus{}use.csv\PYGZdq{},index\PYGZus{}col=0)
light\PYGZus{}in\PYGZus{}use = light\PYGZus{}in\PYGZus{}use[0:72]

plt.plot(range(72),light\PYGZus{}in\PYGZus{}use,label=\PYGZsq{}Light\PYGZsq{})
plt.legend(loc=\PYGZsq{}upper left\PYGZsq{})
plt.xticks(range(0,73,4))
plt.yticks(range(0,251,50))
plt.xlabel(\PYGZsq{}Hour of simulation period\PYGZsq{})
plt.ylabel(\PYGZsq{}Devices in use\PYGZsq{})
plt.title(\PYGZsq{}Number of devices in use\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_12_0}.png}

\sphinxAtStartPar
The number of \sphinxcode{\sphinxupquote{light}} devices in use in a given hour changes
throughout the day: as expected from the utilisation profile, some are
in use overnight, none are in use during the day, and most are in use in
the evenings. Comparing between days, the number of devices in use in a
certain hour also varies.


\subsubsection{Calculating the load profile of each device}
\label{\detokenize{load:calculating-the-load-profile-of-each-device}}
\sphinxAtStartPar
Now that we know the number of each device in use at any given time, and
the power rating of each from the \sphinxstyleemphasis{Device} input CSV, it is
straightforward to get the load profile of each device. \sphinxstylestrong{Run the
following function in the terminal:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Load}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{device\PYGZus{}load\PYGZus{}hourly}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function uses the \sphinxcode{\sphinxupquote{{[}device{]}\_in\_use.csv}} file and the power rating
to save a new CSV file in the \sphinxstyleemphasis{Device Load} folder in the \sphinxstyleemphasis{Load} folder
using the title format \sphinxcode{\sphinxupquote{{[}device{]}\_load.csv}}.

\sphinxAtStartPar
Let’s now compare two devices, \sphinxcode{\sphinxupquote{light}} and \sphinxcode{\sphinxupquote{tv}}, to see how the
number in use and load demand vary over the first three days:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
tv\PYGZus{}in\PYGZus{}use = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Devices in use/tv\PYGZus{}in\PYGZus{}use.csv\PYGZdq{},index\PYGZus{}col=0)
tv\PYGZus{}in\PYGZus{}use = tv\PYGZus{}in\PYGZus{}use[0:72]

fig, ax = plt.subplots(1,2,figsize=(8,4))
ax[0].plot(range(72),light\PYGZus{}in\PYGZus{}use,label=\PYGZsq{}Light\PYGZsq{})
ax[0].plot(range(72),tv\PYGZus{}in\PYGZus{}use,label=\PYGZsq{}TV\PYGZsq{})
ax[0].legend(loc=\PYGZsq{}upper left\PYGZsq{})
ax[0].set(xticks = (range(0,73,6)),yticks = range(0,251,50),
          xlabel = \PYGZsq{}Hour of simulation period\PYGZsq{},
          ylabel = \PYGZsq{}Devices in use\PYGZsq{},
          title = \PYGZsq{}Number of devices in use\PYGZsq{})

light\PYGZus{}load = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device load/light\PYGZus{}load.csv\PYGZdq{},index\PYGZus{}col=0)
light\PYGZus{}load = light\PYGZus{}load[0:72]
tv\PYGZus{}load = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device load/tv\PYGZus{}load.csv\PYGZdq{},index\PYGZus{}col=0)
tv\PYGZus{}load = tv\PYGZus{}load[0:72]

ax[1].plot(range(72),light\PYGZus{}load,label=\PYGZsq{}Light\PYGZsq{})
ax[1].plot(range(72),tv\PYGZus{}load,label=\PYGZsq{}TV\PYGZsq{})
ax[1].legend(loc=\PYGZsq{}upper left\PYGZsq{})
ax[1].set(xticks = (range(0,73,6)),yticks = range(0,701,100),
          xlabel = \PYGZsq{}Hour of simulation period\PYGZsq{},
          ylabel = \PYGZsq{}Load (W)\PYGZsq{},
          title = \PYGZsq{}Load demand from each device\PYGZsq{})

plt.tight\PYGZus{}layout()
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_14_0}.png}

\sphinxAtStartPar
Comparing the two devices, the usage of \sphinxcode{\sphinxupquote{tv}} devices is limited to the
evening periods only and very few are ever in use, owing to the low
average ownership. When we compare the load demanded by each device,
\sphinxcode{\sphinxupquote{tv}} has a more significant effect, albeit still relatively small, as
the relative power rating is higher than that of \sphinxcode{\sphinxupquote{light}}.


\subsubsection{Calculating the total load demand of the community}
\label{\detokenize{load:calculating-the-total-load-demand-of-the-community}}
\sphinxAtStartPar
Knowing the electricity demand of each appliance allows us to combine
these to give the total electricity demand of the entire community over
the duration of the investigation. Once again, CLOVER calculates this
automatically when you \sphinxstylestrong{run the following function in the console:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Load}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{total\PYGZus{}load\PYGZus{}hourly}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function adds together all of the devices listed in the \sphinxstyleemphasis{Device}
input file that have \sphinxcode{\sphinxupquote{Available = Y}} and creates a new CSV in the
\sphinxstyleemphasis{Device load} folder in the \sphinxstyleemphasis{Load} folder called \sphinxcode{\sphinxupquote{total\_load.csv}}.
This also uses another of the input parameters from before, \sphinxcode{\sphinxupquote{Type}}, to
split the load into three categories: \sphinxcode{\sphinxupquote{Domestic}} for households,
\sphinxcode{\sphinxupquote{Commercial}} for businesses and enterprises, and \sphinxcode{\sphinxupquote{Public}} for
community\sphinxhyphen{}level electricity uses.

\sphinxAtStartPar
With this, we now have the necessary load data to input into our
simulations.


\subsection{Troubleshooting}
\label{\detokenize{load:troubleshooting}}
\sphinxAtStartPar
Most of the processes for generating load profile are automated but
there are ample opportunities for simple mistakes when inputting the
data which will cause errors. Solving the issues is normally simple but
finding where they appear can be much harder, so if they come up:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Check that you have used consistent spelling and capitalisation for your devices throughout as these are case sensitive, e.g. \sphinxcode{\sphinxupquote{radio}} and \sphinxcode{\sphinxupquote{Radio}} will be treated as two completely different devices

\item {} 
\sphinxAtStartPar
Check that your file names correspond to the correct devices and are in the correct formats, e.g. \sphinxcode{\sphinxupquote{radio}} has a utilisation profile named \sphinxcode{\sphinxupquote{radio\_times}}

\item {} 
\sphinxAtStartPar
Ensure that your input variables are in the correct format, for example \sphinxcode{\sphinxupquote{Type}} is either \sphinxcode{\sphinxupquote{Domestic}}, \sphinxcode{\sphinxupquote{Commercial}} or \sphinxcode{\sphinxupquote{Public}}

\item {} 
\sphinxAtStartPar
Ensure that your utilisation profiles are the correct size and format, and have the correct naming convention including the \sphinxcode{\sphinxupquote{.csv}} suffix

\item {} 
\sphinxAtStartPar
Ensure that your device power is input in Watts (W), not kilowatts (kW)

\item {} 
\sphinxAtStartPar
Ensure that you have completed each of the steps in the correct order

\end{itemize}


\subsection{Extension and visualisation}
\label{\detokenize{load:extension-and-visualisation}}

\subsubsection{Using your own load profile}
\label{\detokenize{load:using-your-own-load-profile}}
\sphinxAtStartPar
CLOVER gives users the functionality to construct their own load
profiles from the bottom up, but sometimes you already have a load
profile which you want to use directly without trying to recreate it
using the \sphinxstyleemphasis{Load} module. This is straightforward to do, but your own
load profile must be in the same format as the one generated by the
\sphinxstyleemphasis{Load} module. To do this:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ensure that your load profile is in the correct format: at an hourly
resolution for the duration of your simulation period, measured in
Watts (not kilowatts), and with the \sphinxcode{\sphinxupquote{Domestic}}, \sphinxcode{\sphinxupquote{Commercial}} and
\sphinxcode{\sphinxupquote{Public}} headings

\item {} 
\sphinxAtStartPar
Name your profile \sphinxcode{\sphinxupquote{total\_load.csv}} and copy it into the \sphinxstyleemphasis{Device
load} folder in the \sphinxstyleemphasis{Load} folder of your location

\item {} 
\sphinxAtStartPar
Run the function
\sphinxcode{\sphinxupquote{Load().get\_yearly\_load\_statistics(\textquotesingle{}total\_load.csv\textquotesingle{})}} to get the
yearly load statistics

\item {} 
\sphinxAtStartPar
Copy \sphinxcode{\sphinxupquote{kerosene\_load.csv}} into the same folder (the values can be
changed to zero, or the outputs ignored later, as necessary)

\end{itemize}

\sphinxAtStartPar
If you do not have \sphinxcode{\sphinxupquote{Domestic}}, \sphinxcode{\sphinxupquote{Commercial}} and \sphinxcode{\sphinxupquote{Public}} loads, or
they are combined into one category, it is most straightforward to
include them all together in a single headed column (e.g. \sphinxcode{\sphinxupquote{Domestic}}).
The \sphinxcode{\sphinxupquote{kerosene\_load.csv}} needs to be included for compatibility with
the later functionality, but the outputs relating to this can be ignored
or the values in that profile can be set to zero for completeness. The
\sphinxcode{\sphinxupquote{Load().get\_yearly\_load\_statistics(\textquotesingle{}total\_load.csv\textquotesingle{})}} is used later in
the simulation process for sizing equipment (such as the inverters) so
must be updated from the default case study values provided.


\subsubsection{Comparing domestic, commercial and public electricity demand}
\label{\detokenize{load:comparing-domestic-commercial-and-public-electricity-demand}}
\sphinxAtStartPar
Let’s take a look at how the three demand types compare over the first
three days of the simulation period:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import numpy as np

total\PYGZus{}demand = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device load/total\PYGZus{}load.csv\PYGZdq{},index\PYGZus{}col=0)
total\PYGZus{}demand = total\PYGZus{}demand[0:72]

plt.plot(range(72),total\PYGZus{}demand[\PYGZsq{}Domestic\PYGZsq{}],label=\PYGZsq{}Domestic\PYGZsq{})
plt.plot(range(72),total\PYGZus{}demand[\PYGZsq{}Commercial\PYGZsq{}],label=\PYGZsq{}Commercial\PYGZsq{})
plt.plot(range(72),total\PYGZus{}demand[\PYGZsq{}Public\PYGZsq{}],label=\PYGZsq{}Public\PYGZsq{})
plt.plot(range(72),np.sum(total\PYGZus{}demand,axis=1),label=\PYGZsq{}Total\PYGZsq{})
plt.legend(loc=\PYGZsq{}upper right\PYGZsq{})
plt.xticks(range(0,73,4))
plt.yticks(range(0,4501,500))
plt.xlabel(\PYGZsq{}Hour of simulation period\PYGZsq{})
plt.ylabel(\PYGZsq{}Power demand (W)\PYGZsq{})
plt.title(\PYGZsq{}Load profile of the community\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_16_0}.png}

\sphinxAtStartPar
This allows us to compare the different types of demands in the
community and how they vary throughout the day:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Domestic}} demand is highest in the evening due to lighting and entertainment (such as TV) loads

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Commercial}} demand peaks in the day and has high variability caused by a smaller number of higher\sphinxhyphen{}power devices

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Public}} demand, composed here as \sphinxcode{\sphinxupquote{streetlight}} only, has a consistent load profile as it is modelled to operate on a timed basis

\end{itemize}


\subsubsection{Varying demand throughout the year}
\label{\detokenize{load:varying-demand-throughout-the-year}}
\sphinxAtStartPar
We can also see how these demands vary over the year by reformatting the
data into daily demands. For visibility let’s look at a five\sphinxhyphen{}day rolling
average, with the raw data plotted behind it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
total\PYGZus{}demand = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device load/total\PYGZus{}load.csv\PYGZdq{},index\PYGZus{}col=0)
total\PYGZus{}demand = total\PYGZus{}demand[0:8760]

domestic\PYGZus{}demand = 0.001 * np.sum(np.reshape(total\PYGZus{}demand[\PYGZsq{}Domestic\PYGZsq{}].values,(365,24)),axis=1)
commercial\PYGZus{}demand = 0.001 * np.sum(np.reshape(total\PYGZus{}demand[\PYGZsq{}Commercial\PYGZsq{}].values,(365,24)),axis=1)
public\PYGZus{}demand = 0.001 * np.sum(np.reshape(total\PYGZus{}demand[\PYGZsq{}Public\PYGZsq{}].values,(365,24)),axis=1)
total\PYGZus{}demand = 0.001 * np.sum(np.reshape(np.sum(total\PYGZus{}demand,axis=1).values,(365,24)),axis=1)

fig, ax = plt.subplots(1,2,figsize=(8,4))

ax[0].plot(range(365),pd.DataFrame(domestic\PYGZus{}demand).rolling(5).mean(),label=\PYGZsq{}Domestic\PYGZsq{},color=\PYGZsq{}blue\PYGZsq{})
ax[0].plot(range(365),pd.DataFrame(commercial\PYGZus{}demand).rolling(5).mean(),label=\PYGZsq{}Commercial\PYGZsq{},color=\PYGZsq{}orange\PYGZsq{})
ax[0].plot(range(365),pd.DataFrame(public\PYGZus{}demand).rolling(5).mean(),label=\PYGZsq{}Public\PYGZsq{},color=\PYGZsq{}green\PYGZsq{})
ax[0].plot(range(365),domestic\PYGZus{}demand,alpha=0.5,color=\PYGZsq{}blue\PYGZsq{})
ax[0].plot(range(365),commercial\PYGZus{}demand,alpha=0.5,color=\PYGZsq{}orange\PYGZsq{})
ax[0].plot(range(365),public\PYGZus{}demand,alpha=0.5,color=\PYGZsq{}green\PYGZsq{})
ax[0].legend(loc=\PYGZsq{}best\PYGZsq{})
ax[0].set(xticks = (range(0,366,60)),yticks = range(0,26,5),
          xlabel = \PYGZsq{}Day of simulation period\PYGZsq{},
          ylabel = \PYGZsq{}Load (kWh per day)\PYGZsq{},
          title = \PYGZsq{}Energy demand of each load type\PYGZsq{})

ax[1].plot(range(365),pd.DataFrame(total\PYGZus{}demand).rolling(5).mean(),label=\PYGZsq{}Total\PYGZsq{},color=\PYGZsq{}red\PYGZsq{})
ax[1].plot(range(365),total\PYGZus{}demand,alpha=0.5,color=\PYGZsq{}red\PYGZsq{})
ax[1].legend(loc=\PYGZsq{}best\PYGZsq{})
ax[1].set(xticks = (range(0,366,60)),yticks = range(15,41,5),
          xlabel = \PYGZsq{}Day of simulation period\PYGZsq{},
          ylabel = \PYGZsq{}Load (kWh per day)\PYGZsq{},
          title = \PYGZsq{}Total community energy demand\PYGZsq{})

plt.tight\PYGZus{}layout()
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_18_0}.png}

\sphinxAtStartPar
Note that the axes of the two subplots use the same scale but the axis
of the right plot, showing the total community demand, is shifted
upwards. \sphinxcode{\sphinxupquote{Commercial}} demand, as before, displays the largest amount
of variation both between days and over the course of the year, in this
case because of varying agricultural demand. The \sphinxcode{\sphinxupquote{Domestic}} demand has
relatively little day\sphinxhyphen{}to\sphinxhyphen{}day variation but there is a noticeable
decrease in the summer as lighting demand decreases. The growth in
\sphinxcode{\sphinxupquote{Domestic}} device ownership also results in the growth of the daily
load demand (comparing January and December), almost exceeding the
\sphinxcode{\sphinxupquote{Commercial}} demand. Finally the \sphinxcode{\sphinxupquote{Public}} demand remains the same
throughout the year, as expected.

\sphinxAtStartPar
The total community demand is shown on the left. Its structure is mostly
governed by the variation in the \sphinxcode{\sphinxupquote{Commercial}} demand, but the effect
of the \sphinxcode{\sphinxupquote{Domestic}} demand can be seen when comparing the upwards shift
in load comparing the start and end of this year\sphinxhyphen{}long profile.


\subsubsection{Growing demand over the investigation period}
\label{\detokenize{load:growing-demand-over-the-investigation-period}}
\sphinxAtStartPar
We can see how load grows in the community across the investigation
period, for example to replicate how appliance ownership might grow over
time as a community develops economically. Let’s reformat the load data
into yearly totals and compare them across the 20\sphinxhyphen{}year period:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
total\PYGZus{}demand = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Load/Device load/total\PYGZus{}load.csv\PYGZdq{},index\PYGZus{}col=0)

domestic\PYGZus{}demand = 0.000001 * np.sum(np.reshape(total\PYGZus{}demand[\PYGZsq{}Domestic\PYGZsq{}].values,(20,8760)),axis=1)
commercial\PYGZus{}demand = 0.000001 * np.sum(np.reshape(total\PYGZus{}demand[\PYGZsq{}Commercial\PYGZsq{}].values,(20,8760)),axis=1)
public\PYGZus{}demand = 0.000001 * np.sum(np.reshape(total\PYGZus{}demand[\PYGZsq{}Public\PYGZsq{}].values,(20,8760)),axis=1)
total\PYGZus{}demand = 0.000001 * np.sum(np.reshape(np.sum(total\PYGZus{}demand,axis=1).values,(20,8760)),axis=1)

plt.plot(range(20),domestic\PYGZus{}demand,label=\PYGZsq{}Domestic\PYGZsq{},color=\PYGZsq{}blue\PYGZsq{})
plt.plot(range(20),commercial\PYGZus{}demand,label=\PYGZsq{}Commercial\PYGZsq{},color=\PYGZsq{}orange\PYGZsq{})
plt.plot(range(20),public\PYGZus{}demand,label=\PYGZsq{}Public\PYGZsq{},color=\PYGZsq{}green\PYGZsq{})
plt.plot(range(20),total\PYGZus{}demand,label=\PYGZsq{}Total\PYGZsq{},color=\PYGZsq{}red\PYGZsq{})

plt.legend(loc=\PYGZsq{}upper left\PYGZsq{})
plt.xticks(range(0,21,2))
plt.yticks(range(0,71,10))
plt.xlabel(\PYGZsq{}Year of investigation period\PYGZsq{})
plt.ylabel(\PYGZsq{}Energy demand (MWh per year)\PYGZsq{})
plt.title(\PYGZsq{}Load growth of the community\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_20_0}.png}

\sphinxAtStartPar
We can see here that the \sphinxcode{\sphinxupquote{Domestic}} and \sphinxcode{\sphinxupquote{Commercial}} loads both
increase over time, but the \sphinxcode{\sphinxupquote{Domestic}} increases much faster than
\sphinxcode{\sphinxupquote{Commercial}} and therefore is the greatest contributor to the total
load soon after the first year (as we saw in
{\hyperref[\detokenize{load:varying-demand-throughout-the-year}]{\emph{earlier}}}). The \sphinxcode{\sphinxupquote{Public}}
demand meanwhile remains the same throughout.


\section{Electricity system simulation}
\label{\detokenize{energy_system_simulation:electricity-system-simulation}}\label{\detokenize{energy_system_simulation::doc}}

\subsection{Preparation}
\label{\detokenize{energy_system_simulation:preparation}}
\sphinxAtStartPar
Now that we have completed both the electricity
generation and demand inputs for our investigation we are almost
ready to simulate an electricity system. This will allow us to model the
technical performance of an electricity system of a given size and its
ability to meet the load demanded by the community. At this stage we
consider only the technical performance, rather than the financial or
environmental considerations, which will come later when we optimise
the sizing of the systems.

\sphinxAtStartPar
Before we can simulate a system we must first provide inputs for its
technical performance and the conditions of the scenario under which we
want it to operate.


\subsubsection{Electricity system inputs}
\label{\detokenize{energy_system_simulation:electricity-system-inputs}}
\sphinxAtStartPar
The inputs for the technical performance of the system are included in
the \sphinxcode{\sphinxupquote{Energy system inputs}} file, which is located in the \sphinxstyleemphasis{Simulation}
folder of your location folder.

\sphinxAtStartPar
Let’s look at the inputs included for the Bahraich case study:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import pandas as pd
energy\PYGZus{}system\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Simulation/Energy system inputs.csv\PYGZdq{},header=None)
energy\PYGZus{}system\PYGZus{}inputs.head(len(energy\PYGZus{}system\PYGZus{}inputs))
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
These variables control how the electricity system performs, in
particular the performance of the battery storage and the conversion
efficiencies in the system. The table below describes in more detail
what each one means:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery maximum charge}}
&
\sphinxAtStartPar
Maximum permitted state of charge
of the battery
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery minimum charge}}
&
\sphinxAtStartPar
Minimum permitted state of charge
of the battery
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery leakage}}
&
\sphinxAtStartPar
Fraction of the energy stored in
the battery lost per hour
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery conversion in}}
&
\sphinxAtStartPar
Conversion efficiency of energy
entering the battery
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery conversion out}}
&
\sphinxAtStartPar
Conversion efficiency of energy
leaving the battery
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery cycle lifetime}}
&
\sphinxAtStartPar
Number of charging cycles
expected from the battery over
its lifetime
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery C rate discharging}}
&
\sphinxAtStartPar
C\sphinxhyphen{}rate of the battery whilst
providing energy
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery C rate charging}}
&
\sphinxAtStartPar
C\sphinxhyphen{}rate of the battery whilst
receiving energy
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Transmission efficiency DC}}
&
\sphinxAtStartPar
Transmission efficiency of a DC
distribution network
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Transmission efficiency AC}}
&
\sphinxAtStartPar
Transmission efficiency of an AC
distribution network
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DC to AC conversion}}
&
\sphinxAtStartPar
Conversion efficiency from DC
power to an AC distribution
network
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DC to DC conversion}}
&
\sphinxAtStartPar
Conversion efficiency from DC
power to an DC distribution
network
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AC to DC conversion}}
&
\sphinxAtStartPar
Conversion efficiency from AC
power to an DC distribution
network
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AC to AC conversion}}
&
\sphinxAtStartPar
Conversion efficiency from AC
power to an AC distribution
network
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The variables \sphinxcode{\sphinxupquote{Battery maximum charge}} and \sphinxcode{\sphinxupquote{Battery minimum charge}}
refer to the maximum and minimum permitted states of charge of the
battery: in this case the battery is allowed to cycle between 90\% and
40\% of its total capacity, resulting in a depth of discharge (DOD) of
50\%, and meaning that 50\% of the total installed battery capacity is
actually usable by the system. \sphinxcode{\sphinxupquote{Battery leakage}} is the fraction of
energy that leaks out of the battery every hour, in this case \sphinxcode{\sphinxupquote{0.004}}
or 0.4\% of the energy presently stored in it per hour.
\sphinxcode{\sphinxupquote{Battery conversion in}} and \sphinxcode{\sphinxupquote{Battery conversion out}} are the
conversion efficiencies of energy being supplied to and from the battery
respectively; when multiplied together these give the battery round\sphinxhyphen{}trip
efficiency.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery cycle lifetime}} refers to the number of charging and
discharging cycles that the battery can be expected to perform over its
lifetime, with the lifetime defined to be over when the battery has
degraded by \sphinxcode{\sphinxupquote{Battery lifetime loss}}; in this case
\sphinxcode{\sphinxupquote{Battery lifetime loss = 0.2}} (as is typical for this definition) and
so the lifetime is over when the battery provides just 80\% of its
original capacity. The battery degradation is calculated by multiplying
the lifetime loss by the energy throughput of the battery (at a given
point in time) and then dividing by the expected cumulative energy
throughput over the lifetime of the battery (the cycle lifetime
multiplied by the depth of discharge and total capacity). This
simplified method does not account for the effects of temperature or
reduced cycling which may affect the lifetime of a battery in practice.

\sphinxAtStartPar
Finally for the battery parameters, \sphinxcode{\sphinxupquote{Battery C rate discharging}} and
\sphinxcode{\sphinxupquote{Battery C rate charging}} are the C\sphinxhyphen{}rates for discharging and charging
the batteries, measured as the maximum permitted fraction of the battery
capacity that can be stored or supplied in one hour. These battery
parameters can be taken from a datasheet provided by a battery
manufacturer or used as indicative values in more general
investigations. They are also agnostic to the type of battery technology
being investigated, for example lead acid or lithium ion batteries. Some
of these parameters will be dependent on one another: for example, a
given battery being used with a higher DOD will likely have a lower
cycle lifetime. These relationships are often available on battery
datasheets (for example as performance curves) but need to be input
manually and individually here. Similarly, higher C\sphinxhyphen{}rates will also
likely result in lower cycle lifetimes.

\sphinxAtStartPar
Let’s take a look at some of the variables:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
max\PYGZus{}charge = energy\PYGZus{}system\PYGZus{}inputs.iloc[0][1]
min\PYGZus{}charge = energy\PYGZus{}system\PYGZus{}inputs.iloc[1][1]
DOD = max\PYGZus{}charge \PYGZhy{} min\PYGZus{}charge
print(\PYGZsq{}Maximum state of charge: \PYGZsq{} + str((int(100 * max\PYGZus{}charge))) + \PYGZsq{}\PYGZpc{}\PYGZsq{})
print(\PYGZsq{}Minimum state of charge: \PYGZsq{} + str((int(100 * min\PYGZus{}charge))) + \PYGZsq{}\PYGZpc{}\PYGZsq{})
print(\PYGZsq{}Depth of discharge: \PYGZsq{} + str(int(100 * DOD)) + \PYGZsq{}\PYGZpc{}\PYGZbs{}n\PYGZsq{})

battery\PYGZus{}conversion\PYGZus{}in = energy\PYGZus{}system\PYGZus{}inputs.iloc[3][1]
battery\PYGZus{}conversion\PYGZus{}out = energy\PYGZus{}system\PYGZus{}inputs.iloc[4][1]
round\PYGZus{}trip\PYGZus{}efficiency = battery\PYGZus{}conversion\PYGZus{}in * battery\PYGZus{}conversion\PYGZus{}out
print(\PYGZsq{}Battery input efficiency: \PYGZsq{} + str((int(100 * battery\PYGZus{}conversion\PYGZus{}in))) + \PYGZsq{}\PYGZpc{}\PYGZsq{})
print(\PYGZsq{}Battery output efficiency: \PYGZsq{} + str((int(100 * battery\PYGZus{}conversion\PYGZus{}out))) + \PYGZsq{}\PYGZpc{}\PYGZsq{})
print(\PYGZsq{}Round trip efficiency: \PYGZsq{} + str(int(100 * round\PYGZus{}trip\PYGZus{}efficiency)) + \PYGZsq{}\PYGZpc{}\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Maximum} \PYG{n}{state} \PYG{n}{of} \PYG{n}{charge}\PYG{p}{:} \PYG{l+m+mi}{90}\PYG{o}{\PYGZpc{}}
\PYG{n}{Minimum} \PYG{n}{state} \PYG{n}{of} \PYG{n}{charge}\PYG{p}{:} \PYG{l+m+mi}{40}\PYG{o}{\PYGZpc{}}
\PYG{n}{Depth} \PYG{n}{of} \PYG{n}{discharge}\PYG{p}{:} \PYG{l+m+mi}{50}\PYG{o}{\PYGZpc{}}

\PYG{n}{Battery} \PYG{n+nb}{input} \PYG{n}{efficiency}\PYG{p}{:} \PYG{l+m+mi}{95}\PYG{o}{\PYGZpc{}}
\PYG{n}{Battery} \PYG{n}{output} \PYG{n}{efficiency}\PYG{p}{:} \PYG{l+m+mi}{95}\PYG{o}{\PYGZpc{}}
\PYG{n}{Round} \PYG{n}{trip} \PYG{n}{efficiency}\PYG{p}{:} \PYG{l+m+mi}{90}\PYG{o}{\PYGZpc{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The next two variables, \sphinxcode{\sphinxupquote{Transmission efficiency AC}} and
\sphinxcode{\sphinxupquote{Transmission efficiency DC}}, describe the efficiency of the power
distribution network being used to transmit power from the generation
and storage source to the consumers. This can be AC (alternating
current, generally better for high\sphinxhyphen{}power applications and long\sphinxhyphen{}range
transmission) or DC (direct current, generally better for low\sphinxhyphen{}power
applications and short\sphinxhyphen{}range transmission). Only one of these will be
used at a time but both should be completed, for example using a dummy
value if only one is ever to be investigated. Finally,
\sphinxcode{\sphinxupquote{DC to AC conversion}} (for example) gives the conversion efficiency of
DC power sources, such as solar or batteries, to an AC distribution
network. These are the efficiencies of inverters, rectifiers and voltage
converters that would be used in the system; as before, these should all
be included for completeness but dummy values (or the defaults) could be
used if only one distribution network is being considered.

\sphinxAtStartPar
\sphinxstylestrong{Complete the} \sphinxcode{\sphinxupquote{Energy system inputs}} \sphinxstylestrong{CSV with the technical
performance parameters for your investigation.}


\subsubsection{Scenario inputs}
\label{\detokenize{energy_system_simulation:scenario-inputs}}
\sphinxAtStartPar
The inputs which describe the situation we are investigating are
provided in the \sphinxstyleemphasis{Scenario inputs} CSV file in the \sphinxstyleemphasis{Scenario} folder of
your location folder. These describe parameters such as the types of
technologies that are being used in the system and the loads that are
being met. Let’s take a look at the default inputs for Bahraich:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
scenario\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Scenario/Scenario inputs.csv\PYGZdq{},header=None)
scenario\PYGZus{}inputs.head(len(scenario\PYGZus{}inputs))
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
Many of these may be straightforward, but the table below describes them
explicitly.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV}}
&
\sphinxAtStartPar
Whether solar PV is available
(\sphinxcode{\sphinxupquote{Y}}) or not (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery}}
&
\sphinxAtStartPar
Whether battery storage is
available (\sphinxcode{\sphinxupquote{Y}}) or not (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel backup}}
&
\sphinxAtStartPar
Whether a diesel generator backup
is available (\sphinxcode{\sphinxupquote{Y}}) or not
(\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel backup threshold}}
&
\sphinxAtStartPar
The blackout threshold which the
diesel generator is used to
achieve
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid}}
&
\sphinxAtStartPar
Whether the national grid is
available (\sphinxcode{\sphinxupquote{Y}}) or not (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV}}
&
\sphinxAtStartPar
Whether solar PV is available
(\sphinxcode{\sphinxupquote{Y}}) or not (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Prioritise self generation}}
&
\sphinxAtStartPar
Whether to prioritise local
generation (\sphinxcode{\sphinxupquote{Y}}) or energy from
the grid (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Domestic}}
&
\sphinxAtStartPar
Whether \sphinxcode{\sphinxupquote{Domestic}} loads are
included in the load profile
(\sphinxcode{\sphinxupquote{Y}}) or not (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Commercial}}
&
\sphinxAtStartPar
Whether \sphinxcode{\sphinxupquote{Commercial}} loads are
included in the load profile
(\sphinxcode{\sphinxupquote{Y}}) or not (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Public}}
&
\sphinxAtStartPar
Whether \sphinxcode{\sphinxupquote{Public}} loads are
included in the load profile
(\sphinxcode{\sphinxupquote{Y}}) or not (\sphinxcode{\sphinxupquote{N}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Distribution network}}
&
\sphinxAtStartPar
Whether an \sphinxcode{\sphinxupquote{AC}} or \sphinxcode{\sphinxupquote{DC}}
distribtion network is used to
transmit electricity
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The three of the variables, \sphinxcode{\sphinxupquote{PV}}, \sphinxcode{\sphinxupquote{Battery}} and \sphinxcode{\sphinxupquote{Grid}}, are
present for future\sphinxhyphen{}proofing and have no effect at present: solar and
battery storage must be considered in simulations for now, although (as
we will see in {\hyperref[\detokenize{energy_system_simulation:performing-a-simulation-of-an-energy-system}]{\emph{we will see
later}}}) they can have
capacities of zero which mean they are not actually included. Similarly
\sphinxcode{\sphinxupquote{Grid type}} describes the grid availability profile to be used from
the \sphinxstyleemphasis{Grid} module, which can be similarly switched off by selecting a
profile with no availability (e.g. \sphinxcode{\sphinxupquote{Grid type = none}}).

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Diesel backup}} variable is active and controls whether a diesel
generator can be used to supply additional power during times of
blackouts. Periods of blackouts will be described in more detail later,
but for now the \sphinxcode{\sphinxupquote{blackouts}} parameter can be described as the fraction
of time that insufficient energy is available in the system to meet the
loads. If a system of a specified solar and storage capacity, operating
with a given grid availability, has a \sphinxcode{\sphinxupquote{blackouts}} parameter greater
than \sphinxcode{\sphinxupquote{Diesel backup threshold}} then the diesel generator is used
retroactively to top up hours where blackouts occur, up to the point at
which the system \sphinxcode{\sphinxupquote{blackouts}} and \sphinxcode{\sphinxupquote{Diesel backup threshold}} are
equal. For example, if a system had \sphinxcode{\sphinxupquote{blackouts = 0.17}} and (as in
default values) \sphinxcode{\sphinxupquote{Diesel backup threshold = 0.1}}, then the diesel
generator would be used to supply power in 7\% (\sphinxcode{\sphinxupquote{0.07}}) of the hours to
make \sphinxcode{\sphinxupquote{blackouts = 0.10}} after its implementation.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Prioritise self generation}} describes whether the system will use its
own locally\sphinxhyphen{}generated energy from solar first before drawing power from
the grid if available and then storage (\sphinxcode{\sphinxupquote{Y}}), or whether it will take
power from the grid first if available and then from solar and then
storage (\sphinxcode{\sphinxupquote{N}}). In either case, it may be that either locally generated
or grid power is unavailable and therefore this should be thought of as
a prioritisation of sources rather than a backup. In both cases the
diesel backup is considered after this prioritisation occurs.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Domestic}}, \sphinxcode{\sphinxupquote{Commercial}} and \sphinxcode{\sphinxupquote{Public}} refer to whether these
demand types are to be included in the load profile used in the
investigation. Finally the \sphinxcode{\sphinxupquote{Distribution network}} defines whether an
\sphinxcode{\sphinxupquote{AC}} or \sphinxcode{\sphinxupquote{DC}} transmission network is used to distribute electricity
from the sources to the loads, which will affect the conversion
efficiencies used as inputs in the previous section.

\sphinxAtStartPar
\sphinxstylestrong{Complete the} \sphinxcode{\sphinxupquote{Scenario inputs}} \sphinxstylestrong{CSV with the details of the situation
of your investigation.}


\subsection{Performing a simulation of an electricity system}
\label{\detokenize{energy_system_simulation:performing-a-simulation-of-an-electricity-system}}

\subsubsection{Inputs}
\label{\detokenize{energy_system_simulation:inputs}}
\sphinxAtStartPar
We are now able to perform a simulation of an energy system using the
\sphinxstyleemphasis{Energy\_System} module. This relies on all of the information we have
input and generated previously in the electricity
generation and load profiles sections, and the earlier parts of this
section. This will let us investigate the technological performance of a
system with a specified solar and battery capacity, operating under the
conditions we defined earlier.

\sphinxAtStartPar
To perform a simulation we must first \sphinxstylestrong{run the Energy\_System script
(using the green arrow in the Spyder console)}, which we do here using
the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import sys
sys.path.insert(0, \PYGZsq{}/Users/prs09/Documents/CLOVER/Scripts/Simulation scripts/\PYGZsq{})
from Energy\PYGZus{}System import Energy\PYGZus{}System
\end{sphinxVerbatim}

\sphinxAtStartPar
To simulate an energy system we need to specify four further parameters;
these are taken as inputs for convenience when investigating many system
sizes, for example during optimisations which we will explore further
later. These are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{start\_year}}
&
\sphinxAtStartPar
Starting year of the simulation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{end\_year}}
&
\sphinxAtStartPar
End year of the simualation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV\_size}}
&
\sphinxAtStartPar
Installed solar capacity in kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{storage\_size}}
&
\sphinxAtStartPar
Installed battery storage capacity in kWh
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
These tell the function running the simulation both the time period to
consider and the capacity of the system that is being investigated. The
parameters \sphinxcode{\sphinxupquote{start\_year}} and \sphinxcode{\sphinxupquote{end\_year}} are defined by the first day
of their respective years and (as with the rest of Python) start from
\sphinxcode{\sphinxupquote{0}}. For example, running a simulation for only the first year of a
20\sphinxhyphen{}year timeline would require \sphinxcode{\sphinxupquote{start\_year = 0}} and \sphinxcode{\sphinxupquote{end\_year = 1}},
i.e. running from the first day of Year 0 up to (but not including) the
first day of Year 1. These inputs \sphinxstylestrong{must} be integers.

\sphinxAtStartPar
The parameters \sphinxcode{\sphinxupquote{PV\_size}} and \sphinxcode{\sphinxupquote{storage\_size}} refer to the installed
capacities of the solar and battery storage components in their
functional units of kWp and kWh respectively. These inputs can be any
number, including decimals (for example as a multiple of a given solar
panel size) and zero if they are not to be included, as we saw earlier
in \textasciigrave{} \textless{}\#scenario\sphinxhyphen{}inputs\textgreater{}\textasciigrave{}\_\_.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Energy\_System().simulation(...)}} function includes default values
for each of these parameters which are used if the user does not specify
any of their input values. In our example, we will simulate a system
over the first year of its lifetime (\sphinxcode{\sphinxupquote{start\_year = 0, end\_year = 1)}}
and with \sphinxcode{\sphinxupquote{PV\_size = 5}} kWp and \sphinxcode{\sphinxupquote{storage\_size = 20}} kWh.


\subsubsection{Running a simulation}
\label{\detokenize{energy_system_simulation:running-a-simulation}}
\sphinxAtStartPar
To run a simulation we \sphinxstylestrong{run the following function in the console}
with our choice of input variables, saving the output as a variable
called \sphinxcode{\sphinxupquote{example\_simulation}} so we can look at the outputs in more
detail:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
example\PYGZus{}simulation = Energy\PYGZus{}System().simulation(start\PYGZus{}year=0, end\PYGZus{}year=1, PV\PYGZus{}size=5, storage\PYGZus{}size=20)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Time} \PYG{n}{taken} \PYG{k}{for} \PYG{n}{simulation}\PYG{p}{:} \PYG{l+m+mf}{0.45} \PYG{n}{seconds} \PYG{n}{per} \PYG{n}{year}
\end{sphinxVerbatim}

\sphinxAtStartPar
When we run this function we get an output, which we called
\sphinxcode{\sphinxupquote{example\_simulation}}, which is composed of two further outputs: one
describing the technical performance of the system, and one describing
the input parameters that we gave to the function. If we did not save
the output of this function as a variable then the results would have
been printed to the screen, but not available to use later. We also get
an estimate of the time taken to perform each year of the simulation:
running the entire function likely looking much longer than this, but
this value can be useful in identifying potential errors if the value is
much higher for some simulations rather than others.

\sphinxAtStartPar
When this function is called it automatically takes into account all of
the earlier input data and operating conditions to simulate the system
over the defined time period \sphinxhyphen{} making the function itself very
straightforward to use.


\subsubsection{Simulation outputs}
\label{\detokenize{energy_system_simulation:simulation-outputs}}
\sphinxAtStartPar
The important parts of this function are its two outputs which tell us
how the system has performed over the simulated time period. Let’s take
a look at the first component by defining a new variable called
\sphinxcode{\sphinxupquote{example\_simulation\_performance}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
example\PYGZus{}simulation\PYGZus{}performance = example\PYGZus{}simulation[0]
example\PYGZus{}simulation\PYGZus{}performance.head(24).round(3)
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
This component gives the performance of the system at an hourly
resolution, with the first 24 hours of the simulation shown here and
rounded to three decimal places for convenience. They are defined in the
table below:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Load energy (kWh)}}
&
\sphinxAtStartPar
Load energy demanded by the
community
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Total energy used (kWh)}}
&
\sphinxAtStartPar
Total energy used by the
community
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Unmet energy (kWh)}}
&
\sphinxAtStartPar
Energy that would have been
needed to meet energy demand
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Blackouts}}
&
\sphinxAtStartPar
Whether there was a blackout
period (\sphinxcode{\sphinxupquote{1}}) or not (\sphinxcode{\sphinxupquote{0}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Renewables energy used (kWh)}}
&
\sphinxAtStartPar
Renewable energy used directly by
the community
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage energy supplied (kWh)}}
&
\sphinxAtStartPar
Energy supplied by battery
storage
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid energy (kWh)}}
&
\sphinxAtStartPar
Energy supplied by the grid
network
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel energy (kWh)}}
&
\sphinxAtStartPar
Energy supplied by the diesel
generator
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel times}}
&
\sphinxAtStartPar
Whether the diesel generator was
on (\sphinxcode{\sphinxupquote{1}}) or off (\sphinxcode{\sphinxupquote{0}})
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel fuel usage (l)}}
&
\sphinxAtStartPar
Litres of diesel fuel used
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage profile (kWh)}}
&
\sphinxAtStartPar
Dummy profile of energy into (+)
or out of (\sphinxhyphen{}) the battery
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Renewables energy supplied (kWh
)}}
&
\sphinxAtStartPar
Total renewable energy generation
supplied to the system
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Hourly storage (kWh)}}
&
\sphinxAtStartPar
Total energy currently stored in
the battery
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dumped energy (kWh)}}
&
\sphinxAtStartPar
Energy dumped due to
overgeneration when storage is
full
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Battery health}}
&
\sphinxAtStartPar
Measure of the relative health of
the battery
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Households}}
&
\sphinxAtStartPar
Number of households currently in
the community
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Kerosene lamps}}
&
\sphinxAtStartPar
Number of kerosene lamps used
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Kerosene mitigation}}
&
\sphinxAtStartPar
Number of kerosene lamps
mitigated through power
availability
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The majority of these variables describe the energy flows within the
system, the sources that they come from and the amount of load energy
that is being met. Others describe a binary characteristic of whether or
not an hour experiences a blackout (defined as any shortfall in service
availability during that hour) or if a diesel generator is being used,
and others (such as the number of households, kerosene usage and
mitigation, and storage profile) are used either in the computation of
this function or later functions that rely on this output.

\sphinxAtStartPar
Let’s now take a look at the other output of
\sphinxcode{\sphinxupquote{Energy\_System().simulation(...)}}, which we will define as a new
variable called \sphinxcode{\sphinxupquote{example\_system\_description}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
example\PYGZus{}simulation\PYGZus{}description = example\PYGZus{}simulation[1]
example\PYGZus{}simulation\PYGZus{}description.head()
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
This variable provides details of the system that was simulated,
including several of the input variables such as the time period being
investigated and the solar and storage capacities we used. It also
describes three new variables: \sphinxcode{\sphinxupquote{Final PV size}} and
\sphinxcode{\sphinxupquote{Final storage size}} describe the relative capacities of the solar and
battery components at the end of the simulation period after accounting
for degradation, and \sphinxcode{\sphinxupquote{Diesel capacity}} is the minimum diesel generator
capacity (in kW) necessary to supply power as a backup system.

\sphinxAtStartPar
The outputs of this variable are primarily used as inputs for later
functions, particularly those that deal with optimisation as it is
necessary to know the status of an earlier system when considering
periodic improvements over time.


\subsubsection{Saving simulation results and opening saved files}
\label{\detokenize{energy_system_simulation:saving-simulation-results-and-opening-saved-files}}
\sphinxAtStartPar
Saving simulation outputs as variables allows us to explore them in more
detail but, once the session is closed, these variables are deleted and
the data is lost \sphinxhyphen{} meaning that the same simulation would need to be
performed again in order to investigate the same scenario. As the
simulation function relies on data previously stored elsewhere, as long
as the input conditions are unchanged then the same result will be
generated, but this is not convenient in the long term.

\sphinxAtStartPar
CLOVER provides a function to save the output of simulations as CSV
files, storing the data much more conveniently. To save an output
(\sphinxcode{\sphinxupquote{simulation\_name}}) we need to have first stored it as a variable, and
choose a filename (\sphinxcode{\sphinxupquote{filename}}) to store it (note that the \sphinxcode{\sphinxupquote{filename}}
variable in this function must be a string). In our case
\sphinxcode{\sphinxupquote{simulation\_name = example\_simulation\_performance}}, and we choose
\sphinxcode{\sphinxupquote{file\_name = \textquotesingle{}my\_saved\_simulation\textquotesingle{}}}. \sphinxstylestrong{To save the simulation results
we run the function}:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Energy\_System().save\_simulation(simulation\_name = example\_simulation\_performance, filename = \textquotesingle{}my\_saved\_simulation\textquotesingle{})}}

\sphinxAtStartPar
This function creates a new CSV file in the \sphinxstyleemphasis{Saved simulations} folder
in the \sphinxstyleemphasis{Simulation} folder in your location folder titled
\sphinxcode{\sphinxupquote{my\_saved\_simulation.csv}}. If the \sphinxcode{\sphinxupquote{filename}} variable is left blank,
the title of the CSV will default to the time when the save operation
was performed. \sphinxstylestrong{Be aware that running this function with a filename
that already exists will overwrite the existing file}. Notice as well
that we used \sphinxcode{\sphinxupquote{example\_simulation\_performance}} as the variable to be
saved, rather than the two\sphinxhyphen{}component output \sphinxcode{\sphinxupquote{example\_simulation}}:
performing this function with the latter will result in an error.

\sphinxAtStartPar
To open a saved file, we use the name of the CSV file to open the
correct result, for example:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{opened\_simulation = Energy\_System().open\_simulation(filename = \textquotesingle{}my\_saved\_simulation\textquotesingle{})}}

\sphinxAtStartPar
This will open the \sphinxcode{\sphinxupquote{my\_saved\_simulation.csv}} file and record the data
as a new variable, \sphinxcode{\sphinxupquote{opened\_simulation}}, which will be in the same
format as the original saved variable
\sphinxcode{\sphinxupquote{example\_simulation\_performance}}.


\subsection{Troubleshooting}
\label{\detokenize{energy_system_simulation:troubleshooting}}
\sphinxAtStartPar
Most of the \sphinxstyleemphasis{Energy System} functionality is contained within the
\sphinxcode{\sphinxupquote{Energy\_System().simulation(...)}} function and so potential issues are
most likely to come either from how the module gathers data from other
parts of CLOVER:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ensure that the \sphinxcode{\sphinxupquote{self.location}} variable is correct in all of the modules that \sphinxstyleemphasis{Energy\_System} imports

\item {} 
\sphinxAtStartPar
Check that your \sphinxcode{\sphinxupquote{Scenario inputs}} CSV is completed with the scenario you want to investigate, and any changes are saved in the CSV file before running another simulation

\item {} 
\sphinxAtStartPar
Ensure that you use the correct \sphinxcode{\sphinxupquote{filename}} when saving and opening previous simulations

\item {} 
\sphinxAtStartPar
When running simulations, remember to save the output of \sphinxcode{\sphinxupquote{Energy\_System().simulation(...)}} as a variable

\end{itemize}


\subsection{Extension and visualisation}
\label{\detokenize{energy_system_simulation:extension-and-visualisation}}

\subsubsection{Exploring the performance of the system}
\label{\detokenize{energy_system_simulation:exploring-the-performance-of-the-system}}
\sphinxAtStartPar
We can use the \sphinxcode{\sphinxupquote{example\_simulation\_performance}} variable to
investigate the performance of the system. Some variables make more
sense to look at their average over the simulation period:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
example\PYGZus{}simulation\PYGZus{}performance\PYGZus{}averages = example\PYGZus{}simulation\PYGZus{}performance[[\PYGZsq{}Blackouts\PYGZsq{},\PYGZsq{}Diesel times\PYGZsq{}]].mean().round(3)
print(example\PYGZus{}simulation\PYGZus{}performance\PYGZus{}averages)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Blackouts}       \PYG{l+m+mf}{0.100}
\PYG{n}{Diesel} \PYG{n}{times}    \PYG{l+m+mf}{0.104}
\PYG{n}{dtype}\PYG{p}{:} \PYG{n}{float64}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we can see that the average for \sphinxcode{\sphinxupquote{Blackouts}} is \sphinxcode{\sphinxupquote{0.100}} meaning
that power is unavailable for 10\% of the time, or equivalently the
system has power 90\% of the time. We could have expected this from our
earlier condition in the \sphinxcode{\sphinxupquote{Scenario inputs}} CSV which set
\sphinxcode{\sphinxupquote{Diesel backup threshold = 0.1}}, forcing the diesel backup generator
to be used to provide this level of reliability. In this case the
average of \sphinxcode{\sphinxupquote{Diesel times}} is \sphinxcode{\sphinxupquote{0.104}}, meaning that the generator is
switched on for 10.4\% of the time in order to provide the desired level
of reliability.

\sphinxAtStartPar
Other variables make more sense to look at their sum, so here we look at
their performance over the year but then presented as a daily average:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
example\PYGZus{}simulation\PYGZus{}performance\PYGZus{}sums = example\PYGZus{}simulation\PYGZus{}performance[[
    \PYGZsq{}Total energy used (kWh)\PYGZsq{},\PYGZsq{}Unmet energy (kWh)\PYGZsq{},\PYGZsq{}Renewables energy used (kWh)\PYGZsq{},\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{},
    \PYGZsq{}Grid energy (kWh)\PYGZsq{},\PYGZsq{}Diesel energy (kWh)\PYGZsq{},\PYGZsq{}Renewables energy supplied (kWh)\PYGZsq{},\PYGZsq{}Dumped energy (kWh)\PYGZsq{}
    ]].sum()/365.0
print(example\PYGZus{}simulation\PYGZus{}performance\PYGZus{}sums.round(3))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Total} \PYG{n}{energy} \PYG{n}{used} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}             \PYG{l+m+mf}{30.465}
\PYG{n}{Unmet} \PYG{n}{energy} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}                   \PYG{l+m+mf}{0.909}
\PYG{n}{Renewables} \PYG{n}{energy} \PYG{n}{used} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}        \PYG{l+m+mf}{11.940}
\PYG{n}{Storage} \PYG{n}{energy} \PYG{n}{supplied} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}        \PYG{l+m+mf}{7.920}
\PYG{n}{Grid} \PYG{n}{energy} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}                    \PYG{l+m+mf}{7.239}
\PYG{n}{Diesel} \PYG{n}{energy} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}                  \PYG{l+m+mf}{3.366}
\PYG{n}{Renewables} \PYG{n}{energy} \PYG{n}{supplied} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}    \PYG{l+m+mf}{22.656}
\PYG{n}{Dumped} \PYG{n}{energy} \PYG{p}{(}\PYG{n}{kWh}\PYG{p}{)}                  \PYG{l+m+mf}{1.468}
\PYG{n}{dtype}\PYG{p}{:} \PYG{n}{float64}
\end{sphinxVerbatim}

\sphinxAtStartPar
These values show the average daily energy supply and usage in the
system. Here we see that 30.5 kWh per day are consumed by the community,
with a further 0.9 kWh going unmet on average. The supply is composed of
renewable energy from our solar capacity directly (11.9 kWh) and from
the battery storage (7.9 kWh), with the grid (7.2 kWh) and the backup
diesel generator (3.4 kWh) also supplying energy. Our solar capacity
generates an average of 45.3 kWh per day: 13.1 kWh is used directly,
then the rest is stored in the batteries, an average of 1.5 kWh per day
is dumped when the batteries are already full, and the remainder is lost
owing to the transmission and conversion efficiencies in the system.

\sphinxAtStartPar
Adding up the renewables energy used, storage energy, grid energy and
diesel energy gives us the total energy used, and when we also add the
unmet energy this gives us the amount of energy required to meet the
load demanded by the community. This combined value is slightly higher
than the value for load energy from the \sphinxstyleemphasis{Load} module because the former
accounts for the losses in the system needed to entirely satisfy the
latter.


\subsubsection{Electricity usage on an average day}
\label{\detokenize{energy_system_simulation:electricity-usage-on-an-average-day}}
\sphinxAtStartPar
We can use these outputs to visualise the energy flows in the system on
an average day:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

total\PYGZus{}used = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Total energy used (kWh)\PYGZsq{}].values,(365,24)),axis=0)
renewable\PYGZus{}energy = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Renewables energy used (kWh)\PYGZsq{}].values,(365,24)),axis=0)
storage\PYGZus{}energy = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{}].values,(365,24)),axis=0)
grid\PYGZus{}energy = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Grid energy (kWh)\PYGZsq{}].values,(365,24)),axis=0)
diesel\PYGZus{}energy = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Diesel energy (kWh)\PYGZsq{}].values,(365,24)),axis=0)
unmet\PYGZus{}energy = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Unmet energy (kWh)\PYGZsq{}].values,(365,24)),axis=0)
renewables\PYGZus{}supplied = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Renewables energy supplied (kWh)\PYGZsq{}].values,(365,24)),axis=0)

plt.plot(total\PYGZus{}used, label = \PYGZsq{}Total used\PYGZsq{})
plt.plot(renewable\PYGZus{}energy, label = \PYGZsq{}Solar used directly\PYGZsq{})
plt.plot(storage\PYGZus{}energy, label = \PYGZsq{}Storage\PYGZsq{})
plt.plot(grid\PYGZus{}energy, label = \PYGZsq{}Grid\PYGZsq{})
plt.plot(diesel\PYGZus{}energy, label = \PYGZsq{}Diesel\PYGZsq{})
plt.plot(unmet\PYGZus{}energy, label = \PYGZsq{}Unmet\PYGZsq{})
plt.plot(renewables\PYGZus{}supplied, label = \PYGZsq{}Solar generated\PYGZsq{})
plt.legend()
plt.xlim(0,23)
plt.ylim(0,5)
plt.xticks(range(0,24,1))
plt.yticks(range(0,6,1))
plt.xlabel(\PYGZsq{}Hour of day\PYGZsq{})
plt.ylabel(\PYGZsq{}Average energy (kWh per hour)\PYGZsq{})
plt.title(\PYGZsq{}Energy supply and demand on an average day\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_19_0}.png}

\sphinxAtStartPar
Here we can see that, on average, the solar generation in this system
exceeds the demand during the middle of the day, resulting in the total
energy used by the community being almost entirely satisfied by solar
energy. In the evening, when the load demanded by the community
increases and the solar generation decreases, the energy is instead
supplied by a combination of battery storage, the grid network, and the
diesel generator which continue to be used throughout the night.

\sphinxAtStartPar
It is important to note that the values shown here are for an “average”
day and likely not reflective of any single day. Aside from the
variations in solar generation and the load demanded, it is far more
likely that in any given hour only one or two energy sources would be
used at a time. By considering all of the days in the simulation we have
artificially smoothed the data to present the averages.

\sphinxAtStartPar
Let’s instead look at the first day of data for the simulation period:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
total\PYGZus{}used = example\PYGZus{}simulation\PYGZus{}performance.iloc[0:24][\PYGZsq{}Total energy used (kWh)\PYGZsq{}]
renewable\PYGZus{}energy = example\PYGZus{}simulation\PYGZus{}performance.iloc[0:24][\PYGZsq{}Renewables energy used (kWh)\PYGZsq{}]
storage\PYGZus{}energy = example\PYGZus{}simulation\PYGZus{}performance.iloc[0:24][\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{}]
grid\PYGZus{}energy = example\PYGZus{}simulation\PYGZus{}performance.iloc[0:24][\PYGZsq{}Grid energy (kWh)\PYGZsq{}]
diesel\PYGZus{}energy = example\PYGZus{}simulation\PYGZus{}performance.iloc[0:24][\PYGZsq{}Diesel energy (kWh)\PYGZsq{}]
unmet\PYGZus{}energy = example\PYGZus{}simulation\PYGZus{}performance.iloc[0:24][\PYGZsq{}Unmet energy (kWh)\PYGZsq{}]
renewables\PYGZus{}supplied = example\PYGZus{}simulation\PYGZus{}performance.iloc[0:24][\PYGZsq{}Renewables energy supplied (kWh)\PYGZsq{}]

plt.plot(total\PYGZus{}used, label = \PYGZsq{}Total used\PYGZsq{})
plt.plot(renewable\PYGZus{}energy, label = \PYGZsq{}Solar used directly\PYGZsq{})
plt.plot(storage\PYGZus{}energy, label = \PYGZsq{}Storage\PYGZsq{})
plt.plot(grid\PYGZus{}energy, label = \PYGZsq{}Grid\PYGZsq{})
plt.plot(diesel\PYGZus{}energy, label = \PYGZsq{}Diesel\PYGZsq{})
plt.plot(unmet\PYGZus{}energy, label = \PYGZsq{}Unmet\PYGZsq{})
plt.plot(renewables\PYGZus{}supplied, label = \PYGZsq{}Solar generated\PYGZsq{})
plt.legend()
plt.xlim(0,23)
plt.ylim(0,5)
plt.xticks(range(0,24,1))
plt.yticks(range(0,6,1))
plt.xlabel(\PYGZsq{}Hour of day\PYGZsq{})
plt.ylabel(\PYGZsq{}Energy (kWh per hour)\PYGZsq{})
plt.title(\PYGZsq{}Energy supply and demand on a specific day\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_21_0}.png}

\sphinxAtStartPar
As we can see, the data is much spikier as it displays the variation
between consecutive hours, rather than smoother averages. We can see how
once again solar meets most of the demand during the day but during the
evening and night the energy is supplied by either battery storage or,
if available, the national grid \sphinxhyphen{} whose sporadic availability results in
a seemingly peaked supply profile.


\subsubsection{Electricity availability}
\label{\detokenize{energy_system_simulation:electricity-availability}}
\sphinxAtStartPar
We can also use the outputs of \sphinxcode{\sphinxupquote{example\_simulation\_performance}} to
investigate the availability of different electricity services and the
times at which different energy sources are used, including the overall
measure of service availability recorded in the \sphinxcode{\sphinxupquote{Blackouts}} variable.

\sphinxAtStartPar
Let’s once again consider an “average” day to visualise the
availability:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
blackouts = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Blackouts\PYGZsq{}].values,(365,24)),axis=0)
solar\PYGZus{}usage = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Renewables energy used (kWh)\PYGZsq{}].values\PYGZgt{}0,(365,24)),axis=0)
diesel\PYGZus{}times = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Diesel times\PYGZsq{}].values,(365,24)),axis=0)
grid\PYGZus{}usage = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Grid energy (kWh)\PYGZsq{}].values\PYGZgt{}0,(365,24)),axis=0)
storage\PYGZus{}usage = np.mean(np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{}].values\PYGZgt{}0,(365,24)),axis=0)

plt.plot(blackouts, label = \PYGZsq{}Blackouts\PYGZsq{})
plt.plot(solar\PYGZus{}usage, label = \PYGZsq{}Solar\PYGZsq{})
plt.plot(storage\PYGZus{}usage, label = \PYGZsq{}Storage\PYGZsq{})
plt.plot(grid\PYGZus{}usage, label = \PYGZsq{}Grid\PYGZsq{})
plt.plot(diesel\PYGZus{}times, label = \PYGZsq{}Diesel\PYGZsq{})
plt.legend()
plt.xlim(0,23)
plt.ylim(0,1)
plt.xticks(range(0,24,1))
plt.yticks(np.arange(0,1.1,0.25))
plt.xlabel(\PYGZsq{}Hour of day\PYGZsq{})
plt.ylabel(\PYGZsq{}Probability\PYGZsq{})
plt.title(\PYGZsq{}Energy availability on an average day\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_23_0}.png}

\sphinxAtStartPar
Here we can see that the blackout periods are not consistent throughout
the day: although the average is 10\% of the time they are much more
frequent in the early morning, likely because the battery storage is
depleted and the sun has not yet risen. As expected solar energy is
always available (at least somewhat) during the day and never at night.
Battery storage is used most of the time in the evening and more rarely
throughout the night, when grid power is more commonly used. The diesel
generator is also sometimes used during the evening and early hours of
the morning, but rarely throughout the night.


\subsubsection{Visualising seasonality}
\label{\detokenize{energy_system_simulation:visualising-seasonality}}
\sphinxAtStartPar
CLOVER allows us to investigate both the magnitude and timings of
electricity supply and demand in the system at several different
timescales. Given that the demand profiles and resource availability
change throughout the year, it can be useful to visualise the variation
at an annual timescale to identify any seasonal variation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import seaborn as sns

total\PYGZus{}used = np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Total energy used (kWh)\PYGZsq{}].values,(365,24))
renewable\PYGZus{}energy = np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Renewables energy used (kWh)\PYGZsq{}].values,(365,24))
storage\PYGZus{}energy = np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{}].values,(365,24))
grid\PYGZus{}energy = np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Grid energy (kWh)\PYGZsq{}].values,(365,24))
diesel\PYGZus{}energy = np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Diesel energy (kWh)\PYGZsq{}].values,(365,24))
unmet\PYGZus{}energy = np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Unmet energy (kWh)\PYGZsq{}].values,(365,24))
renewables\PYGZus{}supplied = np.reshape(example\PYGZus{}simulation\PYGZus{}performance[\PYGZsq{}Renewables energy supplied (kWh)\PYGZsq{}].values,(365,24))

fig,([ax1,ax2],[ax3,ax4]) = plt.subplots(2,2)\PYGZsh{},sharex=True, sharey=True)
g1 = sns.heatmap(renewable\PYGZus{}energy,
                vmin = 0.0, vmax = 4.0,
                cmap = \PYGZsq{}Reds\PYGZsq{}, cbar=True, ax = ax1)
ax1.set(xticks = range(0,25,6), xticklabels = range(0,25,6),
      yticks = range(0,365,60), yticklabels = range(0,365,60),
      xlabel = \PYGZsq{}Hour of day\PYGZsq{}, ylabel = \PYGZsq{}Day of year\PYGZsq{},
      title = \PYGZsq{}Solar\PYGZsq{})
g2 = sns.heatmap(storage\PYGZus{}energy,
                vmin = 0.0, vmax = 4.0,
                cmap = \PYGZsq{}Greens\PYGZsq{}, cbar=True, ax = ax2)
ax2.set(xticks = range(0,25,6), xticklabels = range(0,25,6),
      yticks = range(0,365,60), yticklabels = range(0,365,60),
      xlabel = \PYGZsq{}Hour of day\PYGZsq{}, ylabel = \PYGZsq{}Day of year\PYGZsq{},
      title = \PYGZsq{}Storage\PYGZsq{})
g3 = sns.heatmap(grid\PYGZus{}energy,
                vmin = 0.0, vmax = 4.0,
                cmap = \PYGZsq{}Blues\PYGZsq{}, cbar=True, ax = ax3)
ax3.set(xticks = range(0,25,6), xticklabels = range(0,25,6),
      yticks = range(0,365,60), yticklabels = range(0,365,60),
      xlabel = \PYGZsq{}Hour of day\PYGZsq{}, ylabel = \PYGZsq{}Day of year\PYGZsq{},
      title = \PYGZsq{}Grid\PYGZsq{})
g4 = sns.heatmap(diesel\PYGZus{}energy,
                vmin = 0.0, vmax = 4.0,
                cmap = \PYGZsq{}Greys\PYGZsq{}, cbar=True, ax = ax4)
ax4.set(xticks = range(0,25,6), xticklabels = range(0,25,6),
      yticks = range(0,365,60), yticklabels = range(0,365,60),
      xlabel = \PYGZsq{}Hour of day\PYGZsq{}, ylabel = \PYGZsq{}Day of year\PYGZsq{},
      title = \PYGZsq{}Diesel\PYGZsq{})
plt.tight\PYGZus{}layout()
fig.suptitle(\PYGZsq{}Electricity from different sources (kWh)\PYGZsq{})
fig.subplots\PYGZus{}adjust(top=0.87)
plt.xticks(rotation = 0)
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_25_0}.png}

\sphinxAtStartPar
From this we can see that, as expected, solar energy provides most of
the energy during the daytime but has periods of reduced supply in the
third quarter of the year. Battery storage provides electricity mainly
during the evening just after the sun goes down, with the time of sunset
visibly later in the day during the middle of the year, whilst the grid
provides power both during the evening and early hours of the morning.
The diesel generator has a more seasonally varying profile: it is used
less often in the summer months, when solar generation is higher and
lasts for longer during the day, pushing back the times when storage is
required and reducing the need for diesel generation.


\section{Electricity system optimisation}
\label{\detokenize{optimisation:electricity-system-optimisation}}\label{\detokenize{optimisation::doc}}

\subsection{Preparation}
\label{\detokenize{optimisation:preparation}}
\sphinxAtStartPar
Now that we can simulate an electricity system we can combine this
information with the costs and impact over its lifetime, and those of
many other system configurations, in order to select the optimum for our
chosen application and criteria. This will allow us to choose the most
suitable combination of generation and storage technologies to meet our
needs most cost effectively, for example.

\sphinxAtStartPar
Before we can do this we need to provide more information about the the
impacts of the installed system, and the conditions that we define to be
the optimum for our scenario.


\subsubsection{Finance inputs}
\label{\detokenize{optimisation:finance-inputs}}
\sphinxAtStartPar
Financial information is often the key decision metric for designing and
implementing a system: renewable energy systems can provide a number of
co\sphinxhyphen{}benefits, but often ultimately need to make financial sense in order
to be selected for deployment. This could be in terms of providing
electricity at a given price, for example lower than the incumbent or
some alternative option, or ensuring that the total cost of a system
does not exceed a certain budget.

\sphinxAtStartPar
The inputs for the financial impact of the system are included in the
\sphinxcode{\sphinxupquote{Finance inputs}} file, which is located in the \sphinxstyleemphasis{Impact} folder of your
location folder. Let’s take a look at the inputs for the Bahraich case
study:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import pandas as pd
finance\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Impact/Finance inputs.csv\PYGZdq{},header=None)
finance\PYGZus{}inputs.head(len(finance\PYGZus{}inputs))
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
These variables describe the costs of the various elements of the energy
system and will be dependent on the specifics of your location; although
this is true for all of the input files, the costs are likely to vary
significantly between locations and can also have a relatively large
impact on the results of your optimisation. These data can be difficult
to assign specific values (for example if different suppliers have
different costs for a given component, or if lower costs are available
for purchasing larger quantities) so the general ethos should be to use
a value reflective of what is available for your location. Take care to
notice the units of each variable as using an input in the wrong units
would affect the costs significantly. The table below describes in more
detail what each variable means:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Discount rate}}
&
\sphinxAtStartPar
The discount rate or cost of
finance, expressed as a fraction
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV cost}}
&
\sphinxAtStartPar
Cost of PV modules in \$/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV O\&M}}
&
\sphinxAtStartPar
The annual cost of maintaining PV
modules in \$/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV cost decrease}}
&
\sphinxAtStartPar
The annual cost decrease of PV
modules in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage cost}}
&
\sphinxAtStartPar
The cost of storage in \$/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage O\&M}}
&
\sphinxAtStartPar
The annual cost of maintaining
storage in \$/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage cost decrease}}
&
\sphinxAtStartPar
The annual cost decrease of
storage in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel generator cost}}
&
\sphinxAtStartPar
Cost of a diesel generator in
\$/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel generator cost decrease}}
&
\sphinxAtStartPar
The annual cost decrease of a
diesel generator in  \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel fuel cost}}
&
\sphinxAtStartPar
Cost of diesel fuel in \$/litre
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel fuel cost decrease}}
&
\sphinxAtStartPar
The annual cost decrease of
diesel fuel in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel O\&M}}
&
\sphinxAtStartPar
The annual cost of maintaining
the diesel generator in \$/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BOS cost}}
&
\sphinxAtStartPar
Cost of balance of systems (BOS)
components for PV in \$/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BOS cost decrease}}
&
\sphinxAtStartPar
The annual cost decrease of BOS
components in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV installation cost}}
&
\sphinxAtStartPar
Cost of installing PV modules in
\$/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV installation cost decrease}}
&
\sphinxAtStartPar
The annual cost decrease of
installing PV modules in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel installation cost}}
&
\sphinxAtStartPar
Cost of installing diesel
generators in \$/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel installation cost decrea
se}}
&
\sphinxAtStartPar
The annual cost decrease of
installing diesel generators in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Connection cost}}
&
\sphinxAtStartPar
The cost of connecting a
household to the system in \$
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Kerosene cost}}
&
\sphinxAtStartPar
The cost of using a kerosene lamp
for one hour in \$
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid cost}}
&
\sphinxAtStartPar
The cost of grid electricity in
\$/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid extension cost}}
&
\sphinxAtStartPar
The cost of extending the grid by
1 km in \$
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid infrastructure cost}}
&
\sphinxAtStartPar
The cost of transformers (etc.)
to connect the system to the grid
in \$
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter cost}}
&
\sphinxAtStartPar
Cost of an inverter in \$/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter cost decrease}}
&
\sphinxAtStartPar
The annual cost decrease of an
inverter in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter lifetime}}
&
\sphinxAtStartPar
The lifetime of an inverter in
years
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter size increment}}
&
\sphinxAtStartPar
The variety of available sizes of
inverters in kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Misc. costs}}
&
\sphinxAtStartPar
General miscellaneous
capacity\sphinxhyphen{}dependent costs for the
system in \$/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{General O\&M}}
&
\sphinxAtStartPar
General miscellaneous annual
costs for the system in \$ per
year
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The first variable, \sphinxcode{\sphinxupquote{Discount rate}}, describes the cost of financing
used when considering the value of money over time. This is input here
as a fraction, \sphinxcode{\sphinxupquote{0.1}}, corresponding to a discount rate of 10\%. The
cost of financing can vary significantly between countries and projects
depending on many factors, such as the risk associated with the project,
and can affect the cost effectiveness of different technologies: broadly
speaking, a high discount rate will discourage large initial investment
(for example in solar and storage capacity) and favour repeated
expenditure over time (for example on diesel fuel).

\sphinxAtStartPar
The costs of solar generation, diesel and storage technologies are
treated similarly. Each has a cost associated with purchasing the
equipment and maintaining it dependent on the total capacity installed,
and an annual cost decrease representing how costs of technology can
change over time (we define these variables as a decrease, so a positive
value represents costs falling over time whilst a negative value
represents them increasing). The diesel generator has additional
variables associated with the cost of fuel, solar generation has those
for balance of system components such as frames and wiring, and both
have costs of initially installing the generation capacity; these are
all treated in a similar way.

\sphinxAtStartPar
Two variables relate directly to households in the system. The first is
\sphinxcode{\sphinxupquote{Connection cost}}, which represents the cost of connecting a household
to the system; this could include wiring, electricity meters,
installation costs, or any others related to providing a household with
a connection. The second is \sphinxcode{\sphinxupquote{Kerosene cost}}, which is the cost that a
household incurs for using one kerosene lamp for one hour. This would
mainly be comprised of the cost of kerosene fuel, but could also include
a contribution to the cost of the lamp itself although this will likely
be negligible. This variable is used to calculate the spending on
kerosene by the community when electricity is unavailable.

\sphinxAtStartPar
The cost of electricity from the grid used by the system is assigned in
\sphinxcode{\sphinxupquote{Grid cost}}. Additional costs associated with the national grid are
\sphinxcode{\sphinxupquote{Grid extension cost}}, which represents the cost of extending the
network to the community being investigated if it is not currently
present there, and \sphinxcode{\sphinxupquote{Grid infrastructure cost}}, which is the cost of
the transformers and other equipment used to convert power from the grid
for use in the local distribution network. At present
\sphinxcode{\sphinxupquote{Grid extension cost}} is not used in the financial calculations, but
could be used in the future to calculate the breakeven distance at which
an off\sphinxhyphen{}grid system is more cost effective than extending the national
network.

\sphinxAtStartPar
Variables about the inverter used in the system are also included here,
with the cost and cost decrease acting similarly to those for generation
and storage capacities. In addition the lifetime of the inverter, in
years, is included to govern the points in the simulation at which the
inverter must be replaced and a new one is purchased; this is included
here as depending on the length of a simulation period and its point in
the overall lifetime of the system it may necessitate several, or no,
replacements. The \sphinxcode{\sphinxupquote{Inverter size increment}} variable describes the
capacity of inverters that are available to be used: for example if this
variable is set to 3 kW then the system can used an inverter with a 3
kW, 6 kW, or 9 kW (and so on) capacity, with the inverter being
oversized as necessary.

\sphinxAtStartPar
Finally, \sphinxcode{\sphinxupquote{Misc. costs}} and \sphinxcode{\sphinxupquote{General O\&M}} can be used to include any
additional miscellaneous costs that are not captured in the other
variables and that are dependent on either the capacity of the system or
are annually recurring, respectively.

\sphinxAtStartPar
If you are not using certain technologies in your investigation then it
is not necessary to provide values for all of the variables included
here. For example, if you are evaluating a solar and battery storage
system operating far from the national grid network, you do not need to
input values relating to diesel generators, fuel, or the cost of
electricity from the national grid. In this case it is best to leave the
default values in place or set them to zero, rather than delete them, to
ensure that you do not introduce any issues in the way that CLOVER reads
the CSV file.

\sphinxAtStartPar
These variables are designed to enumerate the financial inputs into
separate and easy\sphinxhyphen{}to\sphinxhyphen{}update categories, but some can be combined if
necessary if their units allows. For example, if a supplier is offering
that a complete solar system can be installed for a given price, this
can be captured in \sphinxcode{\sphinxupquote{PV cost}} on its own rather than also trying to
assign values to \sphinxcode{\sphinxupquote{BOS cost}} and \sphinxcode{\sphinxupquote{PV installation cost}} (which here
could be set to zero as they are included in \sphinxcode{\sphinxupquote{PV cost}}). Likewise if
the system is maintained by a single operator, and is not dependent on
the capacity that has been installed, it may make more sense to include
their salary in \sphinxcode{\sphinxupquote{General O\&M}} and set \sphinxcode{\sphinxupquote{PV O\&M}} (etc.) to be zero;
this method would not consider other capacity\sphinxhyphen{}dependent costs however,
such as minor replacement parts.

\sphinxAtStartPar
\sphinxstylestrong{Complete the} \sphinxcode{\sphinxupquote{Finance inputs}} \sphinxstylestrong{CSV file with the financial
information for your investigation.}


\subsubsection{Environmental inputs}
\label{\detokenize{optimisation:environmental-inputs}}
\sphinxAtStartPar
CLOVER allows users to analyse the environmental impact of their systems
to explore the potential benefits of low\sphinxhyphen{}carbon energy technologies. At
present these are considered using the greenhouse gas (GHG) emissions of
the various technologies both in terms of embedded GHGs from their
manufacture and the impact over their lifetimes, for example through the
carbon intensity of the electricity they provide. These can be compared
to alternatives, such as the carbon intensity of the national grid
network, to advocate for cleaner sources of power.

\sphinxAtStartPar
The inputs for the environmental impact of the system are included in
the \sphinxcode{\sphinxupquote{GHG inputs}} file, which is located in the \sphinxstyleemphasis{Impact} folder of your
location folder. Let’s take a look at the inputs for the Bahraich case
study:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
GHG\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Impact/GHG inputs.csv\PYGZdq{},header=None)
GHG\PYGZus{}inputs.head(len(GHG\PYGZus{}inputs))
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
Similarly to the financial inputs, the environmental inputs consider the
initial impact of installing the technologies (the embedded GHG
emissions from their manufacture) and the impact of maintaining them, as
well as the potential for technologies to decrease their impact over
time as manufacturing becomes more efficient, for example. These data
are typically much more difficult to identify values for as the
environmental impact is rarely considered in such detail, if at all, as
a secondary metric to the financial impact. As a result it may be better
to either use the default values provided or set them to zero to
disregard them depending on the nature of your investigation; either may
be appropriate, as long as the decision is acknowledged and justified
where necessary. The table below describes in more detail what each
variable means:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV GHGs}}
&
\sphinxAtStartPar
GHGs of PV modules in kgCO2/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV O\&M GHGs}}
&
\sphinxAtStartPar
The annual cost of maintaining PV
modules in kgCO2/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV GHGs decrease}}
&
\sphinxAtStartPar
The annual GHG decrease of PV
modules in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage GHGs}}
&
\sphinxAtStartPar
The GHGs of storage in kgCO2/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage O\&M GHGs}}
&
\sphinxAtStartPar
The annual GHGs of maintaining
storage in kgCO2/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage GHGs decrease}}
&
\sphinxAtStartPar
The annual GHG decrease of
storage in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel generator GHGs}}
&
\sphinxAtStartPar
GHGs of a diesel generator in
kgCO2/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel generator GHG decrease}}
&
\sphinxAtStartPar
The annual GHG decrease of a
diesel generator in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel fuel GHGs}}
&
\sphinxAtStartPar
GHGs of diesel fuel in
kgCO2/litre
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel O\&M GHGs}}
&
\sphinxAtStartPar
The annual GHGs of maintaining
the diesel generator in kgCO2/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BOS GHGs}}
&
\sphinxAtStartPar
GHGs of balance of systems (BOS)
components for PV in kgCO2/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BOS GHGs decrease}}
&
\sphinxAtStartPar
The annual GHG decrease of BOS
components in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV installation GHGs}}
&
\sphinxAtStartPar
GHGs of installing PV modules in
kgCO2/kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV installation GHGs decrease}}
&
\sphinxAtStartPar
The annual GHG decrease of
installing PV modules in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel installation GHGs}}
&
\sphinxAtStartPar
GHGs of installing diesel
generators in kgCO2/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel installation GHGs decrea
se}}
&
\sphinxAtStartPar
The annual GHGs decrease of
installing diesel generators in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Connection GHGs}}
&
\sphinxAtStartPar
The GHGs of connecting a
household to the system in kgCO2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Kerosene GHGs}}
&
\sphinxAtStartPar
The GHGs of using a kerosene lamp
for one hour in kgCO2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid GHGs (initial)}}
&
\sphinxAtStartPar
The GHGs of grid electricity at
the start of the time period in
kgCO2/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid GHGs (final)}}
&
\sphinxAtStartPar
The GHGs of grid electricity at
the end of the time period in
kgCO2/kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid extension GHGs}}
&
\sphinxAtStartPar
The GHGs of extending the grid by
1 km in kgCO2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Grid infrastructure GHGs}}
&
\sphinxAtStartPar
The GHGs of transformers (etc.)
to connect the system to the grid
in kgCO2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter GHGs}}
&
\sphinxAtStartPar
GHGs of an inverter in kgCO2/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter GHGs decrease}}
&
\sphinxAtStartPar
The annual GHG decrease of an
inverter in \%
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter lifetime}}
&
\sphinxAtStartPar
The lifetime of an inverter in
years
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inverter size increment}}
&
\sphinxAtStartPar
The variety of available sizes of
inverters in kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Misc. GHGs}}
&
\sphinxAtStartPar
General miscellaneous
capacity\sphinxhyphen{}dependent GHGs for the
system in kgCO2/kW
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{General O\&M GHGs}}
&
\sphinxAtStartPar
General miscellaneous annual GHGs
for the system in kgCO2 per year
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Almost all of the variables in the above table are environmental
analogues to those in the financial inputs and therefore their
descriptions will not be repeated here. The exceptions to this are
\sphinxcode{\sphinxupquote{Grid GHGs (initial)}} and \sphinxcode{\sphinxupquote{Grid GHGs (final)}}, which describe the
emissions intensity of the grid network at the start and end of the
considered lifetime of the system respectively. These allow the user to
take into account how the electricity grid might be decarbonised over
time in line with national policy objectives, which would have a
subsequent impact on the GHGs of a system using grid electricity
throughout its lifetime.

\sphinxAtStartPar
In general many of the technologies have relatively carbon\sphinxhyphen{}intensive
manufacturing processes, such as processing silicon for solar panels and
smelting metals for balance of systems components and wiring, whilst
diesel fuel has notoriously high emissions from its usage. Emissions
associated with operation and maintenance could come from the
maintenance itself (for example replacement parts) or other
considerations, such as the GHGs of a worker travelling to the site; in
practice, however, these O\&M emissions are usually dwarfed by the
embedded emissions of equipment and those from diesel fuel and the
national grid. Emissions from transporting equipment are not explicitly
included but can be implicitly included by adding them to the
appropriate variables, for example setting \sphinxcode{\sphinxupquote{PV GHGs}} to a value
including both the emissions from manufacturing a panel and from
shipping it to the installation site (both in terms of capacity, here
kgCO2/kWp).

\sphinxAtStartPar
\sphinxstylestrong{Complete the} \sphinxcode{\sphinxupquote{GHG inputs}} \sphinxstylestrong{CSV file with the financial information
for your investigation.}


\subsubsection{Optimisation inputs}
\label{\detokenize{optimisation:optimisation-inputs}}
\sphinxAtStartPar
The optimisation process in CLOVER is mostly automatic but in order for
it to work we need to state the conditions under which it should
operate. CLOVER performs a large number of system simulations, each with
different combinations of generation and storage capacity sizes, and
appraises them based on their technical, financial and environmental
performances; depending on our interests, any of them might be
considered “the best”. For this reason we need to provide CLOVER with
some details about what we consider to be the “optimum” system using two
variables that we define:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxstyleemphasis{threshold criterion}, which determines whether a simulated system meets the standards required to be considered as a potential optimum system, and

\item {} 
\sphinxAtStartPar
The \sphinxstyleemphasis{optimisation criterion}, which determines which of the potential systems is selected to be the best.

\end{itemize}

\sphinxAtStartPar
Simply put, the threshold criterion decides whether a system meets our
stated needs and, as many systems are likely to be able to meet our
needs, the optimisation criterion selects the one that performs the best
according to its financial or environmental impact. As an example,
consider that we want to design a system which provides electricity 95\%
of the time or more: clearly many systems will be able to do that, some
much larger than would be affordable, so we decide that the one which
provides the lowest cost of electricity would be best. Here we would
define the threshold criterion to be \sphinxcode{\sphinxupquote{Blackouts}} (from
earlier set to a value of \sphinxcode{\sphinxupquote{0.05}} (i.e. a
maximum of 5\% blackouts), whilst the optimisation criterion would be the
levelised cost of used electricity in \$/kWh (LCUE, explained further
later) with the lowest being the best. CLOVER would then identify a
system which meets those two criteria, and give us a range of other
impact metrics as well.

\sphinxAtStartPar
We also need to provide information about scenario we are investigating:
optimising over different time periods will potentially provide
different results as resource generation, load demands, technological
performance and degradation all change over time. CLOVER uses a
step\sphinxhyphen{}by\sphinxhyphen{}step optimisation process which divides the total investigation
lifetime into shorter time periods; this allows us to replicate the
process of designing a system to meet some future needs, then revisiting
the system after a few years to upgrade it as necessary to meet a
growing demand or maintain its performance. This also allows us to
consider that additional capacity in the context of what has already
been installed, adding only what is necessary rather than overhauling
the existing equipment.

\sphinxAtStartPar
The inputs for the optimisation parameters are included in the
\sphinxcode{\sphinxupquote{Optimisation inputs}} file, which is located in the \sphinxstyleemphasis{Optimisation}
folder of your location folder. Let’s take a look at the inputs for the
Bahraich case study:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
optimisation\PYGZus{}inputs = pd.read\PYGZus{}csv(\PYGZdq{}/Users/prs09/Documents/CLOVER/Locations/Bahraich/Optimisation/Optimisation inputs.csv\PYGZdq{},header=None)
optimisation\PYGZus{}inputs.head(len(optimisation\PYGZus{}inputs))
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
Some of the variables included in the \sphinxcode{\sphinxupquote{Optimisation inputs}} CSV file
are not used by the current optimisation function. These were left over
from previous processes which have since been improved to increase the
speed and efficiency of the overall optimisation. These previous
functions (and their input variables) are \sphinxstyleemphasis{deprecated}, meaning that
they are not used by the standard processes in the model but are still
present in dormant sections of the code and can be used if specifically
desired by the user. For clarity, these functions are not covered in
this document but their variables are still included in the
\sphinxcode{\sphinxupquote{Optimisation inputs}} CSV file for completeness.

\sphinxAtStartPar
The table below describes in more detail what each variable means:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Scenario length}}
&
\sphinxAtStartPar
Total length of the investigation
period in years
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Iteration length}}
&
\sphinxAtStartPar
Length of each step\sphinxhyphen{}by\sphinxhyphen{}step time
period in years
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV size (min)}}
&
\sphinxAtStartPar
Minimum size of PV capacity to be
considered in kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV size (max)}}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Deprecated}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV size (step)}}
&
\sphinxAtStartPar
Optimisation resolution for PV
size in kWp
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PV size (increase)}}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Deprecated}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage size (min)}}
&
\sphinxAtStartPar
Minimum size of storage capacity
to be considered in kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage size (max)}}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Deprecated}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage size (step)}}
&
\sphinxAtStartPar
Optimisation resolution for
storage size in kWh
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Storage size (increase)}}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Deprecated}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Threshold criterion}}
&
\sphinxAtStartPar
Criterion for identifying
sufficient systems
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Threshold value}}
&
\sphinxAtStartPar
Value required for a system to be
considered sufficient
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Optimisation criterion}}
&
\sphinxAtStartPar
Criterion for identifying optimum
system
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Two variables control the length of the investigation period and that of
each of the sub\sphinxhyphen{}periods, with the total \sphinxcode{\sphinxupquote{Scenario length}} comprised of
several \sphinxcode{\sphinxupquote{Iteration length}}. For example, setting
\sphinxcode{\sphinxupquote{Scenario length = 12}} and \sphinxcode{\sphinxupquote{Iteration length = 4}} would mean that
there would be three distinct periods: the first considering the first
four years, the second considering the next four years (including the
performance of the system that was already installed for the period
before), and the third considering the last set of four years (again
including the periods before). \sphinxcode{\sphinxupquote{Scenario length}} must be a multiple of
\sphinxcode{\sphinxupquote{Iteration length}} for the optimisation process to work, and
\sphinxcode{\sphinxupquote{Scenario length}} can be any length up to the total investigation
lifetime we defined in defined earlier to be 20 years.

\sphinxAtStartPar
The optimisation process in CLOVER first considers a system with the
smallest generation and storage capacity and gradually increases it
until it finds one that meets the threshold criterion. The first system
it considers at the start of the investigation period, with the smallest
installed capacity, is defined by \sphinxcode{\sphinxupquote{PV size (min)}} and
\sphinxcode{\sphinxupquote{Storage size (min)}}. These variables identify the starting point of
the optimisation which, for many, would be no installed capacity at all
\sphinxhyphen{} meaning \sphinxcode{\sphinxupquote{PV size (min) = 0}} and \sphinxcode{\sphinxupquote{Storage size (min) = 0}}. If there
is already a system in place then set these variables to the capacity of
that system. When CLOVER moves on to the second (or later) iterations
during the optimisation process it automatically considers the capacity
that was installed during the previous time period.

\sphinxAtStartPar
The optimisation function requires the user to define the resolution of
the investigation, defined through the variables \sphinxcode{\sphinxupquote{PV size (step)}} and
\sphinxcode{\sphinxupquote{Storage size (step)}} respectively: once CLOVER has investigated a
system it then analyses one with a larger capacity, with the increase in
capacity of the next system defined by these two variables. For example,
with \sphinxcode{\sphinxupquote{PV size (step) = 1}} CLOVER would consider systems with
\sphinxcode{\sphinxupquote{PV size = 0, 1, 2, 3, ...}} whereas \sphinxcode{\sphinxupquote{PV size (step) = 5}} would
consider \sphinxcode{\sphinxupquote{PV size = 0, 5, 10, 15, ...}}, with the same logic being true
for \sphinxcode{\sphinxupquote{Storage size (step)}}. Both variables can be set to different
values, and can be non\sphinxhyphen{}integers. For an investigation of a theoretical
system then choosing a round number for the step size might be more
convenient, but for a real investigation it could be better to use the
real available capacity of the equipment being installed. For example,
if you know that the system will be build using solar panels with a
capacity of 350 Wp, you could choose to use \sphinxcode{\sphinxupquote{PV size (step) = 0.35}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Threshold criterion}} is the name of the variable being used to decide
whether a system provides sufficient performance to be considered as a
potential optimum system, as described earlier, with \sphinxcode{\sphinxupquote{Threshold value}}
being the value it must meet. The choices for \sphinxcode{\sphinxupquote{Threshold criterion}}
are described later in described later and
CLOVER knows automatically whether the \sphinxcode{\sphinxupquote{Threshold value}} should be
considered as a maximum or minimum value: for example, if
\sphinxcode{\sphinxupquote{Threshold criterion = Blackouts}} then CLOVER interprets
\sphinxcode{\sphinxupquote{Threshold value = 0.05}} as systems are permitted to have blackout
periods for a maximum of 5\% of the time. \sphinxcode{\sphinxupquote{Optimisation criterion}},
meanwhile, is the variable being used to select the optimum system and
CLOVER similarly knows whether this should be interpreted as a maximum
or minimum: for example, \sphinxcode{\sphinxupquote{Optimisation criterion = LCUE (\$/kWh)}} would
be used to find the lowest cost of electricity. Take care that the
inputs for \sphinxcode{\sphinxupquote{Threshold criterion}} and \sphinxcode{\sphinxupquote{Optimisation criterion}} are
spelled correctly, otherwise the optimisation process will not work.


\subsubsection{Considerations}
\label{\detokenize{optimisation:considerations}}
\sphinxAtStartPar
CLOVER can take a number of variables as either the threshold or
optimisation criteria and these should be chosen to best reflect the
context of the investigation and its goals. Typically the threshold
criterion relates to the technological performance of the system on the
basis that, in order for a system to be viable, it needs to be able to
provide a minimum level of service to the community which is (almost
always) based on its core technical functionality, rather than economic
or environmental factors. The level of service availability, either in
terms of the time energy is (un)available or the proportion of demanded
that should be met, are the most commonly used threshold criteria.
Selecting an appropriate threshold value will vary depending on the
situation, for example a system for basic domestic applications could
permit blackouts 5\sphinxhyphen{}10\% of the time whilst one for a hospital may need 0\%
system downtime.

\sphinxAtStartPar
The optimisation criterion, meanwhile, is typically a measure of the
system impact either in financial or environmental terms. Most commonly
this is the levelised cost of used electricity (LCUE, measured in
\$/kWh), which considers the cost of power over the lifetime of the
system and is normally most relevant to system designers, but could also
be other financial metrics such as the total system cost which may be
more relevant to donor\sphinxhyphen{}led projects. Environmental analogues of these
metrics, such as the emissions intensity of electricity or the
cumulative GHG emissions, may be more relevant for projects driven by
climate change objectives.

\sphinxAtStartPar
Whilst a single criterion must be selected for use in the optimisation
process, as we will see in we will see later
the optimisation process gives us all of the available outputs and so we
can investigate all of them for an optimum system configuration. Using
different optimisation criteria may yield different results but often
the optimum systems will be relatively similar: for a given level of
service availability, it is likely that the capacity of a system
optimised for lowest cost of electricity will be similar to one
optimised for lowest cumulative cost, but may not be identical.

\sphinxAtStartPar
Choosing the resolution of an optimisation is a trade\sphinxhyphen{}off between
precision and computation time. Taking the above example of 1 kWp or 5
kWp resolutions, the former method would be more likely to suggest a
system closer to the true optimum: for example, if the true optimum
system (if it were possible to know it exactly) has \sphinxcode{\sphinxupquote{PV size = 7}} then
the former method would be able to find it, but the latter method would
suggest either \sphinxcode{\sphinxupquote{PV size = 5}} or \sphinxcode{\sphinxupquote{PV size = 10}}, depending on how the
other aspects of system influence this. Even if the true optimum system
is actually \sphinxcode{\sphinxupquote{PV size = 7.2}}, the former method still gets closer.

\sphinxAtStartPar
The importance of a precise answer will depend on the requirements of
your investigation, the size of the system, your available processing
power and your patience, so there is no exact answer for the “best” step
sizes to use. In general, it is good practice to run an initial
optimisation with a low resolution (e.g. \sphinxcode{\sphinxupquote{PV size = 10}}) to get an
idea of the order of magnitude of the system: if the optimum output for
this trial run is \sphinxcode{\sphinxupquote{PV size = 20}}, it would be appropriate to re\sphinxhyphen{}run
the optimisation with a higher resolution (e.g. step sizes of 1 kWp or 5
kWp) to gain greater precision. If the output is \sphinxcode{\sphinxupquote{PV size = 300}}, it
might be better to increase the step size (e.g. to 20 kWp) to reduce
computational time.

\sphinxAtStartPar
The optimisation process CLOVER uses provides the optimum system for the
iteration period under consideration, which is not necessarily the same
as one for the entire lifetime of the system. This is to replicate
real\sphinxhyphen{}life system design and the timeframes of community energy projects,
where plans are built around time horizons of a few years owing to
practical constraints such as funding, the limits of demand prediction,
or the likelihood of altering the business model. This also matches a
reasonable timeframe of making major upgrades to the system, for example
returning to the site every few years to perform capacity upgrades to
meet a growing demand. As such CLOVER identifies the optimum system for
the next short\sphinxhyphen{}term time window, providing the system that best meets
the requirements for the next stage of design, before moving on to the
next stage in time. This allows users to know the optimum system for the
immediate future and what subsequent system upgrades might look like to
maintain that optimum performance. As will all predictions the further
into the future you consider the greater uncertainty there is, but
remember that you can always return in a few years’ time to re\sphinxhyphen{}run your
optimisation when it’s time to upgrade your system.

\sphinxAtStartPar
As a result the of the precision of your system, the CLOVER optimisation
process might suggest different pathways of capacity sizing over the
lifetime of the system. In the example above, if a system requires
\sphinxcode{\sphinxupquote{PV size = 7.2}} in its first period and \sphinxcode{\sphinxupquote{PV size = 12.1}} in its
second then using a \sphinxcode{\sphinxupquote{PV size (step)}} of 1 kWp would probably give
\sphinxcode{\sphinxupquote{PV size = 7}} and \sphinxcode{\sphinxupquote{PV size = 12}}, but using a step size of 10 kWp
might give \sphinxcode{\sphinxupquote{PV size = 10}} for both periods. The latter case might have
evaluated the relative costs and benefits of increasing the capacity to
\sphinxcode{\sphinxupquote{PV size = 20}} and found that (for example) increasing the storage
capacity instead was more worthwhile. The precision we chose has
therefore locked the two optimisations into different pathways, one with
a larger PV capacity and one with a larger storage capacity; both will
provide the same level of service (as the threshold criteria are the
same in both cases) but the optimisation impacts such as the costs will
be different. In some cases this effect can be exacerbated over several
time periods, but in general the most effective way to mitigate this is
through using higher precision in your optimisations to stay as close as
possible to the true optimum system.

\sphinxAtStartPar
\sphinxstylestrong{Complete the} \sphinxcode{\sphinxupquote{Optimisation inputs}} \sphinxstylestrong{CSV file with the optimisation
information for your investigation.}


\subsection{Performing an optimisation of an energy system}
\label{\detokenize{optimisation:performing-an-optimisation-of-an-energy-system}}

\subsubsection{Preparation}
\label{\detokenize{optimisation:id1}}
\sphinxAtStartPar
We are now able to perform an optimisation of an energy system using the
Optimisation module. This relies on all of the information we have input
and generated previously in the electricity system simulation section and
the earlier parts of this section. This will let us identify the optimum
system, find its solar and battery capacity, and get information about
its technological performance and its financial and environmental
impacts.

\sphinxAtStartPar
To perform an optimisation we must first \sphinxstylestrong{run the Optimisation script
(using the green arrow in the Spyder console)}, which we do here using
the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import sys
sys.path.insert(0, \PYGZsq{}/Users/prs09/Documents/CLOVER/Scripts/Optimisation scripts/\PYGZsq{})
from Optimisation import Optimisation
\end{sphinxVerbatim}

\sphinxAtStartPar
The optimisation function we will use does not take any arguments from
the console as they are all included in the previous CSV files. We can
override them in the function but this is generally for specific
applications which are not relevant here.


\subsubsection{Running an optimisation}
\label{\detokenize{optimisation:running-an-optimisation}}
\sphinxAtStartPar
To run an optimisation we \sphinxstylestrong{run the following function in the console},
saving the output as a variable called \sphinxcode{\sphinxupquote{example\_optimisation}} so we
can look at the outputs in more detail:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{example\PYGZus{}optimisation} \PYG{o}{=} \PYG{n}{Optimisation}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{multiple\PYGZus{}optimisation\PYGZus{}step}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will run the optimisation function, which automatically simulates a
variety of systems with different capacity sizes until it finds the
optimum configuration. \sphinxstylestrong{The optimisation process can take a long time
to complete}, ranging from minutes to hours depending on your scenario
and available computing resources (hence the advice to begin at a
relatively low resolution to get an idea of the expected system size).
If you need to cancel the optimisation function before it completes,
click on the console and press \sphinxcode{\sphinxupquote{Ctrl + C}} on your keyboard.

\sphinxAtStartPar
Whilst the optimisation function runs it outputs some information to the
screen to update on its progress. An example is below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Step} \PYG{l+m+mi}{1} \PYG{n}{of} \PYG{l+m+mi}{3}

\PYG{n}{Time} \PYG{n}{taken} \PYG{k}{for} \PYG{n}{simulation}\PYG{p}{:} \PYG{l+m+mf}{0.16} \PYG{n}{seconds} \PYG{n}{per} \PYG{n}{year}

\PYG{n}{Current} \PYG{n}{system}\PYG{p}{:} \PYG{n}{Blackouts} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{Target} \PYG{o}{=} \PYG{l+m+mf}{0.05}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, the function is considering the first four\sphinxhyphen{}year period in
the twelve\sphinxhyphen{}year lifetime (\sphinxcode{\sphinxupquote{Step 1 of 3}}). As before when running a
simulation, it prints information about the speed at which the
simulations are being performed. Finally it presents some information
about the performance of the system it just simulated in terms of the
chosen threshold criterion (\sphinxcode{\sphinxupquote{Blackouts = 0.1}}) and the desired target
set by the \sphinxcode{\sphinxupquote{Optimisation inputs}} CSV file (\sphinxcode{\sphinxupquote{Target = 0.05}}).

\sphinxAtStartPar
In this case, we can notice that all of the systems have
\sphinxcode{\sphinxupquote{Blackouts = 0.1}} or lower, even for the very first system that is
simulated which has \sphinxcode{\sphinxupquote{PV\_size = 0}} and \sphinxcode{\sphinxupquote{storage\_size = 0}}. This is
because the \sphinxcode{\sphinxupquote{Diesel backup = Y}} and \sphinxcode{\sphinxupquote{Diesel backup threshold = 0.1}}
(from earlier) which means that the diesel
generator is activated to provide \sphinxcode{\sphinxupquote{Blackouts = 0.1}} at the very least.
Because we set the threshold criterion higher than this, the system is
unable to use diesel alone to meet the requirements thereby forcing it
to install some renewable capacity to reach \sphinxcode{\sphinxupquote{Blackouts = 0.05}}. We
could have set \sphinxcode{\sphinxupquote{Diesel backup threshold = 0.05}} to potentially allow
the use of diesel generation to meet our target, but in our case this
results in a diesel\sphinxhyphen{}dominated system which doesn’t provide a good
example!

\sphinxAtStartPar
A few other statements are shown in the console that update you on what
the optimisation process is doing. \sphinxcode{\sphinxupquote{Using single line optimisation}}
means that CLOVER is scanning along a fixed capacity of either PV or
storage whilst varying the other, whilst \sphinxcode{\sphinxupquote{Increasing storage size}} and
\sphinxcode{\sphinxupquote{Increasing PV size}} describe the steps CLOVER is taking to identify
the optimum system by checking larger configurations. These are for
information only so there is no need to do anything with this
information.

\sphinxAtStartPar
Finally, when the optimisation is complete, you receive the message:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Time} \PYG{n}{taken} \PYG{k}{for} \PYG{n}{optimisation}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15} \PYG{n}{minutes}
\end{sphinxVerbatim}

\sphinxAtStartPar
This lets you know how long the entire optimisation process took (in
this case just over 10 minutes). This is for information only but you
can use it to judge how to amend your resolution for your next
optimisation, or to know approximately how long you will need to wait
next time you optimise the system.

\sphinxAtStartPar
Opening the \sphinxcode{\sphinxupquote{example\_optimisation}} variable allows us to view the
results of the optimisation function, which are presented in a table.
Each row corresponds to an iteration period (in our case, three) with
the columns describing the results for each stage of the optimisation.
There is a large number of results and so we will discuss them in more
detail later.


\subsubsection{Saving optimisation results and opening saved files}
\label{\detokenize{optimisation:saving-optimisation-results-and-opening-saved-files}}
\sphinxAtStartPar
Similarly to the reasons for saving simulation results described earlier
it is
important to save the optimisation results for future reference. It is
especially important because of the time it takes to run optimisations,
which can be much longer than any single simulation.

\sphinxAtStartPar
CLOVER provides a function to save the output of optimisations as CSV
files, storing the data much more conveniently. To save an output
(\sphinxcode{\sphinxupquote{optimisation\_name}}) we need to have first stored it as a variable,
and choose a filename (\sphinxcode{\sphinxupquote{filename}}) to store it (note that the
\sphinxcode{\sphinxupquote{filename}} variable in this function must be a string). In our case
\sphinxcode{\sphinxupquote{optimisation\_name}} = \sphinxcode{\sphinxupquote{example\_optimisation}}, and we choose
\sphinxcode{\sphinxupquote{file\_name = \textquotesingle{}my\_saved\_optimisation\textquotesingle{}}}. \sphinxstylestrong{To save the optimisation
results we run the function}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Optimisation}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{save\PYGZus{}optimisation}\PYG{p}{(}\PYG{n}{optimisation\PYGZus{}name} \PYG{o}{=} \PYG{n}{example\PYGZus{}optimisation}\PYG{p}{,}
        \PYG{n}{filename} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}saved\PYGZus{}optimisation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function creates a new CSV file in the \sphinxstyleemphasis{Saved optimisations} folder
in the \sphinxstyleemphasis{Optimisation} folder in your location folder titled
\sphinxcode{\sphinxupquote{my\_saved\_optimisation.csv}}. If the filename variable is left blank,
the title of the CSV defaults to the time the save operation was
performed. Be aware that running this function with a filename that
already exists will overwrite the existing file.

\sphinxAtStartPar
To open a saved file, we use the name of the CSV file to open the
correct result, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{opened\PYGZus{}optimisation} \PYG{o}{=} \PYG{n}{Optimisation}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{open\PYGZus{}optimisation}\PYG{p}{(}\PYG{n}{filename} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}saved\PYGZus{}optimisation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will open the \sphinxcode{\sphinxupquote{my\_saved\_optimisation.csv}} file and record the
data as a new variable, \sphinxcode{\sphinxupquote{opened\_optimisation}}, which will be in the
same format as the original saved variable \sphinxcode{\sphinxupquote{example\_optimisation}}.


\subsubsection{Optimisation results}
\label{\detokenize{optimisation:optimisation-results}}
\sphinxAtStartPar
Our optimisation function gives us a large number of results in its
output variable. Let’s open the example saved optimisation file, located
in the \sphinxstyleemphasis{Bahraich} folder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
opened\PYGZus{}optimisation = Optimisation().open\PYGZus{}optimisation(filename = \PYGZsq{}my\PYGZus{}saved\PYGZus{}optimisation\PYGZsq{})
opened\PYGZus{}optimisation.T.head(len(opened\PYGZus{}optimisation.T)).round(3)
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
Note that here we have displayed the outputs vertically (rather than
horizontally as in the default) so that they are easier to see. These
results are automatically generated as a result of the optimisation
process but it is also possible to calculate them for a specific case
study system, described later when we return to system performance.

\sphinxAtStartPar
Many of these variables have similar names, so here are some pointers on
interpreting them:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Cumulative} means that the variable is a running total since the
start of the system lifetime (i.e. the current period and all
previous periods)

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{New} means the variable includes only the current period

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Cost} values are all discounted costs, meaning they take into account the discount rate, and are presented in terms of \$ at the start of the lifetime

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{System} means the electricity system (PV and storage capacity, O\&M,
diesel, grid, connections)

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Total} refers to the costs from all sources (i.e. the \sphinxstyleemphasis{system} and
kerosene expenditure) a each time period

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Energy} is either the amount of energy or (when specified) the
discounted energy which takes into account the discount rate

\end{itemize}

\sphinxAtStartPar
These identifiers (or the names themselves) should provide enough
description to work out what each variable means. Now let’s consider a
few of the most relevant ones that you’re most likely to use in more
detail:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Start / End year}}
&
\sphinxAtStartPar
The first and last years in each
considered period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Initial PV / storage size}}
&
\sphinxAtStartPar
Installed capacity of PV/storage
at the start of the period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Final PV / storage size}}
&
\sphinxAtStartPar
Equivalent capacity of PV/storage
at the end of the period, after
degradation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Diesel capacity}}
&
\sphinxAtStartPar
Installed capacity of diesel
generator required for backup
(kW)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LCUE (\$/kWh)}}
&
\sphinxAtStartPar
Levelised cost of used
electricity up to the end of the
simulation period (\$/kWh)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Emissions intensity (gCO2/kWh)}}
&
\sphinxAtStartPar
Emissions intensity up to the end
of the simulation period
(gCO2/kWh)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Blackouts}}
&
\sphinxAtStartPar
Proportion of time where
blackouts occurred for each
iteration period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Unmet energy fraction}}
&
\sphinxAtStartPar
Proportion unmet energy for each
iteration period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Renewables fraction}}
&
\sphinxAtStartPar
Proportion energy from PV and
storage for each iteration period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Kerosene displacement}}
&
\sphinxAtStartPar
Proportion kerosene mitigated
during each iteration period
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Cumulative cost (\$)}}
&
\sphinxAtStartPar
Running total of cumulative costs
over the system lifetime in \$
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Cumulative GHGs (kgCO2eq)}}
&
\sphinxAtStartPar
Running total of cumulative GHGs
over the system lifetime in
kgCO2eq
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The first variables are useful in characterising the iteration period
(\sphinxcode{\sphinxupquote{Start year}} and \sphinxcode{\sphinxupquote{End year}}) and knowing the capacity of the system
that was installed (\sphinxcode{\sphinxupquote{Initial PV size}} and \sphinxcode{\sphinxupquote{Initial storage size}}),
possibly the most important variables in terms of describing the system
itself. The \sphinxcode{\sphinxupquote{Final PV size}} and \sphinxcode{\sphinxupquote{Final storage size}} describe the
state of the equipment at the end of the iteration period, incorporating
the effects of degradation. Note that for the next iteration period,
CLOVER may choose to “refresh” the installed capacity either by
returning it to the same initial size from the previous iteration or
increasing it, or leave it “as is” and not add any further capacity. In
the latter case the final size from the previous iteration would be the
initial size of the next; this is relatively common for systems without
growing load profiles. Finally \sphinxcode{\sphinxupquote{Diesel capacity}} describes the size of
the diesel generator installed to provide power as a backup.

\sphinxAtStartPar
The remaining variables in the table are useful to use as either
threshold or optimisation criteria for designing your system: many of
the variables in \sphinxcode{\sphinxupquote{example\_optimisation}} could be used for this
purpose, but these are the most commonly used and most likely to be
relevant for your investigation. Bear in mind that \sphinxstylestrong{the input for}
\sphinxcode{\sphinxupquote{Threshold criterion}} \sphinxstylestrong{or} \sphinxcode{\sphinxupquote{Optimisation criterion}} \sphinxstylestrong{must match the
variable name exactly} otherwise the function will fail. For example,
\sphinxcode{\sphinxupquote{LCUE (\$/kWh)}} would work but \sphinxcode{\sphinxupquote{LCUE}} would not.

\sphinxAtStartPar
Two important variables relate to the financial and environmental impact
of the system at each point in its lifetime: the levelised cost of used
electricity (LCUE, \$/kWh) and emissions intensity (gCO2/kWh). These are
convenient metrics of capturing the performance of the system per unit
of electricity and so are readily comparable to other systems for the
same (or other) applications. The LCUE is the most common optimisation
criterion as it conveniently captures core financial information which
is readily comparable to other situations. LCUE considers only the
energy \sphinxstyleemphasis{used} by the community, explicitly defined as the useful
electricity actually consumed rather than (for example) all of the
electricity that was generated, some of which was likely dumped if
demand was already met. Furthermore this definition accounts for
blackout periods when electricity was demanded, but unmet.

\sphinxAtStartPar
For each iteration step these variables provide information about the
LCUE and emissions intensity by the end of that step: for example, the
LCUE over the first time period is \sphinxcode{\sphinxupquote{\$0.65/kWh}} but falls to
\sphinxcode{\sphinxupquote{\$0.35/kWh}} by the end of the optimisation period over the whole
lifetime. This is because the impacts of deploying the equipment occur
at the start of each period but their benefits, in terms of the
electricity they provide, are received over the total remaining lifetime
of the system including subsequent iteration periods. The assumption
here is that a community energy project would need to purchase equipment
outright before it can be deployed, reflecting common practice, but
would not capture more nuanced financial plans which would require
further development outside of CLOVER.

\sphinxAtStartPar
The next set of variables describe the performance of the system during
each iteration period. These can be used as optimisation criteria but
are also very useful as threshold criteria and each period is considered
independently to ensure the minimum performance threshold is met
throughout. If this were not the case, if the first period performed
very well then the second could perform below the expectation of the
threshold, if the average over the entire period still satisfied the
defined threshold value. As before \sphinxcode{\sphinxupquote{Blackouts}} and
\sphinxcode{\sphinxupquote{Unmet energy fraction}} describe the service unavailability in terms
of the proportion of time electricity is not available and the
proportion of energy demand that is not satisfied by the system, and
when used as a threshold criterion are defined as the maximum allowable
value for a system to be sufficient. \sphinxcode{\sphinxupquote{Renewables fraction}} describes
the proportion of energy that was supplied by either solar or storage
(i.e. not from the grid or diesel generation), whilst
\sphinxcode{\sphinxupquote{Kerosene displacement}} describes the proportion of kerosene usage
that was mitigated by the availability of electricity. For the latter
two variables, these are considered a minimum allowable value when used
as a threshold criterion.

\sphinxAtStartPar
Finally, \sphinxcode{\sphinxupquote{Cumulative cost (\$)}} and \sphinxcode{\sphinxupquote{Cumulative GHGs (kgCO2eq)}} are
running totals of the cumulative incurred costs or GHGs up to the point
of each iteration period. These are the best values for capturing the
entire impact of the scenario over its lifetime, including impacts from
all sources including kerosene usage. For the impacts of the electricity
system alone, \sphinxcode{\sphinxupquote{Cumulative system cost (\$)}} and
\sphinxcode{\sphinxupquote{Cumulative system GHGs (kgCO2eq)}} can instead be used (if kerosene
usage was not already disregarded earlier). In this case, the total
lifetime impact of the system (and residual kerosene usage) was that it
cost around \$58,000 and emitted around 170 tCO2 to supply power to the
community of 100 households for 12 years.

\sphinxAtStartPar
\sphinxstylestrong{You now should have everything you need to investigate your scenarios,
perform optimisations and design electricity systems. Good luck!}


\subsection{Troubleshooting}
\label{\detokenize{optimisation:troubleshooting}}
\sphinxAtStartPar
Most of the \sphinxstyleemphasis{Optimisation} functionality is contained within the
\sphinxcode{\sphinxupquote{Optimisation().multiple\_optimisation\_step()}} function and so
potential issues are most likely to come either from how the module
gathers data from other parts of CLOVER or from the input CSV files.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ensure that the \sphinxcode{\sphinxupquote{self.location}} variable is correct in all of the
modules that \sphinxcode{\sphinxupquote{Optimisation}} imports

\item {} 
\sphinxAtStartPar
Check that your \sphinxcode{\sphinxupquote{Finance inputs}}, \sphinxcode{\sphinxupquote{GHG inputs}} and
\sphinxcode{\sphinxupquote{Optimisation inputs}}, CSVs are completed with the scenario you
want to investigate, and any changes are saved in the CSV file before
running another simulation

\item {} 
\sphinxAtStartPar
Check that your \sphinxcode{\sphinxupquote{Scenario inputs}} CSV is completed with the
scenario you want to investigate and the \sphinxstyleemphasis{Energy\_System} module is
working correctly

\item {} 
\sphinxAtStartPar
Ensure that you use the correct filename when saving and opening
previous simulations

\item {} 
\sphinxAtStartPar
When running optimisations, remember to save the output of
\sphinxcode{\sphinxupquote{Optimisation().multiple\_optimisation\_step()}} as a variable

\end{itemize}


\subsection{Extension and visualisation}
\label{\detokenize{optimisation:extension-and-visualisation}}

\subsubsection{Changing parameter optimisation}
\label{\detokenize{optimisation:changing-parameter-optimisation}}
\sphinxAtStartPar
Investigating the design of a system under a given threshold criterion
allows us to identify the optimum configuration under those conditions,
but in many cases the target value of the threshold criterion might be
negotiable. A common example is the tradeoff between the reliability of
the system and the cost of electricity: with all other scenario
conditions being the same, a more reliable system will need greater
generation and storage capacities which will increase the investment
required and so increase the cost of electricity. It is often
interesting, therefore, to investigate a range of values for the
threshold criterion to see what effect it has on the resulting
optimisation criterion, and from those options select a system that best
suits our needs.

\sphinxAtStartPar
We can demonstrate the above example by considering a system with the
\sphinxcode{\sphinxupquote{Optimisation criterion}} as \sphinxcode{\sphinxupquote{LCUE (\$/kWh)}} and the
\sphinxcode{\sphinxupquote{Threshold criterion}} as \sphinxcode{\sphinxupquote{Blackouts}} as before, but with a range of
\sphinxcode{\sphinxupquote{Threshold value}}. Whereas before we set this to be \sphinxcode{\sphinxupquote{0.05}}, we now
want to optimise using several options ranging from \sphinxcode{\sphinxupquote{0.25}} to \sphinxcode{\sphinxupquote{0.05}}
in steps of \sphinxcode{\sphinxupquote{0.05}}. All of the other inputs in the
\sphinxcode{\sphinxupquote{Optimisation inputs}} CSV file are the same as the earlier
example but we have set \sphinxcode{\sphinxupquote{Diesel backup = N}}
in the \sphinxcode{\sphinxupquote{Scenario inputs}} CSV file to avoid the diesel generator
backup improving the reliability, in order to better demonstrate our
goal here.

\sphinxAtStartPar
We can use the below function to automatically perform several
optimisations in a row and save the results to CSV files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Optimisation}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{changing\PYGZus{}parameter\PYGZus{}optimisation}\PYG{p}{(}\PYG{n}{parameter} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Threshold value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{parameter\PYGZus{}values} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.25}\PYG{p}{,}\PYG{l+m+mf}{0.20}\PYG{p}{,}\PYG{l+m+mf}{0.15}\PYG{p}{,}\PYG{l+m+mf}{0.10}\PYG{p}{,}\PYG{l+m+mf}{0.05}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{results\PYGZus{}folder\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Changing parameter example}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function takes more variables than the usual
\sphinxcode{\sphinxupquote{Optimisation().multiple\_optimisation\_step()}} function as it
repeatedly uses that function, with changing parameters, to perform
several optimisations. Be aware that, by doing this, the
\sphinxcode{\sphinxupquote{Optimisation().changing\_parameter\_optimisation(...)}} function takes
several times longer to finish and, when investigating systems with the
strictest threshold values, can take much more time than previous
optimisations you might have performed.

\sphinxAtStartPar
We define which parameter we want to change each time using the
\sphinxcode{\sphinxupquote{parameter}} input, which can correspond to any variable in the
\sphinxcode{\sphinxupquote{Optimisation inputs}} CSV file. Here we want to investigate the effect
of using different values for the threshold criterion, so we set
\sphinxcode{\sphinxupquote{parameter = \textquotesingle{}Threshold value\textquotesingle{}}}. Next we need to specify the values we
want to investigate which we input as a \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}type variable; using
the information above, we therefore input
\sphinxcode{\sphinxupquote{parameter\_values = {[}0.25,0.20,0.15,0.10,0.05{]}}}. The list of
\sphinxcode{\sphinxupquote{parameter\_values}} can be as long or short as desired. This will run
the optimisation function sequentially for each value
(\sphinxcode{\sphinxupquote{Threshold value = 0.25}}, \sphinxcode{\sphinxupquote{Threshold value = 0.20}}, …,
\sphinxcode{\sphinxupquote{Threshold value = 0.05}}) by automatically rewriting the
\sphinxcode{\sphinxupquote{Optimisation inputs}} CSV file: be aware that the final rewrite will
leave the final \sphinxcode{\sphinxupquote{Threshold value}} in the file, so you may need to
remember to amend this if you use the usual
\sphinxcode{\sphinxupquote{Optimisation().multiple\_optimisation\_step()}} again.

\sphinxAtStartPar
Finally, the results of each optimisation are saved in a folder with the
name \sphinxcode{\sphinxupquote{results\_folder\_name}} in the \sphinxstyleemphasis{Saved optimisations} folder in your
\sphinxstyleemphasis{Optimisation} folder, which itself is in the overall file structure for
your location. Here we use
\sphinxcode{\sphinxupquote{results\_folder\_name = \textquotesingle{}Changing parameter example\textquotesingle{}}} to specify the
place where the outputs should be saved. The folder must be manually
created beforehand in order to save the files there, otherwise they will
be saved in a new folder with the date and time the function was
performed.

\sphinxAtStartPar
Whilst running, the function will save the outputs of each optimisation
as a CSV with the name \sphinxcode{\sphinxupquote{Threshold value = 0.25.csv}} (and so on) to
allow you to investigate each system individually afterwards. Once the
entire function is complete, it outputs a summary file of the final
results for each optimised system in the file
\sphinxcode{\sphinxupquote{Threshold value lifetime summary of results.csv}} (the name of this
file will change if you used a different \sphinxcode{\sphinxupquote{parameter}}). This is
composed of the final row of each optimisation so bear in mind that some
of the data refers to a single iteration period when interpreting the
results and refer to the section on optimisation results for guidance. If you
need to cancel the function for any reason, the output CSVs that have
already been saved will still be available but this final CSV will not,
as it is compiled at the end of the process (but can be manually
compiled if necessary).

\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{parameter = \textquotesingle{}Threshold value\textquotesingle{}}} is the most common usage of this
function to set the process running self\sphinxhyphen{}sufficiently, allowing you to
leave it to work away in the background without intervention and return
results when they are ready. It is also possible to use it for other
types of investigations, but be sure to think carefully how these would
be interpreted by the function. For example, if you wanted to
investigate the effect on the system of either using a threshold value
of \sphinxcode{\sphinxupquote{0.05}} for either the \sphinxcode{\sphinxupquote{Blackouts}} or \sphinxcode{\sphinxupquote{Unmet energy fraction}},
you could use \sphinxcode{\sphinxupquote{parameter = \textquotesingle{}Threshold criterion\textquotesingle{}}} and
\sphinxcode{\sphinxupquote{parameter\_values = {[}\textquotesingle{}Blackouts\textquotesingle{}, \textquotesingle{}Unmet energy fraction\textquotesingle{}{]}}}. Or if you
wanted to find an optimum systems with the lowest cost of electricity or
lowest emissions intensity, you could use
\sphinxcode{\sphinxupquote{parameter = \textquotesingle{}Optimisation criterion\textquotesingle{}}} and
\sphinxcode{\sphinxupquote{parameter\_values = {[}\textquotesingle{}LCUE (\$/kWh)\textquotesingle{}, \textquotesingle{}Emissions intensity (gCO2/kWh)\textquotesingle{}{]}}}.
Owing to the variety of potential combinations they have not all been
tested so unexpected bugs may occur, in which case please get in touch.


\subsubsection{Interpreting optimisation results}
\label{\detokenize{optimisation:interpreting-optimisation-results}}
\sphinxAtStartPar
The meaning and implications of your optimisation results will depend
very strongly on your scenario and the goals of your investigation:
CLOVER can provide results but the value is in interpreting them and
applying them in the context of your project. With that in mind, we can
use the example in the changing parameter optimisation section to
demonstrate some of the techniques that could be useful.

\sphinxAtStartPar
As stated earlier, the goal of this investigation was to see what effect
different levels of reliability (from \sphinxcode{\sphinxupquote{Blackouts = 0.25}} to
\sphinxcode{\sphinxupquote{Blackouts = 0.05}}) would have on the optimum system design, defined
to be the one with the lowest LCUE. Let’s open the results we generated
previously:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
optimisation\PYGZus{}example = Optimisation().open\PYGZus{}optimisation(filename = \PYGZsq{}/Changing parameter example/Threshold value lifetime summary of results\PYGZsq{})
optimisation\PYGZus{}example.T.head(len(optimisation\PYGZus{}example.T)).round(3)
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
Once again we have displayed the outputs vertically to make them easier
to see. The results in this table are characterised from left to right
in terms of the \sphinxcode{\sphinxupquote{Parameter value}}, here our range from 25\% to 5\%
blackouts. An important note here is that \sphinxstyleemphasis{Total} now refers to the
lifetime cumulative cost, rather than the final iteration as it was
before. The fraction of energy from each source considers only the
energy used in the system (i.e. after the \sphinxcode{\sphinxupquote{Unmet fraction}} has been
taken out), and \sphinxcode{\sphinxupquote{Renewables fraction}} refers to energy from renewable
generation used directly, with \sphinxcode{\sphinxupquote{Storage fraction}} accounted for
separately. The differences in naming conventions come from different
versions of the model which have been updated and modified over time, so
bear this in mind and refer to the documentation when interpreting the
outputs.

\sphinxAtStartPar
Let’s look at how the different \sphinxcode{\sphinxupquote{parameter\_values}} we used in the
function impact the LCUE graphically:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

plt.bar(range(5),optimisation\PYGZus{}example[\PYGZsq{}LCUE (\PYGZdl{}/kWh)\PYGZsq{}],tick\PYGZus{}label=optimisation\PYGZus{}example[\PYGZsq{}Parameter value\PYGZsq{}])
plt.xlabel(\PYGZsq{}Blackout threshold value\PYGZsq{})
plt.ylabel(\PYGZsq{}LCUE (\PYGZdl{}/kWh)\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_17_0_opt}.png}

\sphinxAtStartPar
As expected the value of LCUE, our chosen optimisation criterion,
increases for more reliable systems: if the community are willing to pay
more for electricity then the most reliable system may be appropriate,
but if not then perhaps a less reliable but more affordable system would
be better. It is worth noting here that whilst we set \sphinxcode{\sphinxupquote{Blackouts}} to
be the threshold criterion, the actual levels of blackouts in each
system was always lower:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
blackouts = optimisation\PYGZus{}example[[\PYGZsq{}Parameter value\PYGZsq{},\PYGZsq{}Blackouts\PYGZsq{}]]
blackouts.head().round(3)
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
This is because the actual value of \sphinxcode{\sphinxupquote{Blackouts}} must always be equal
to or lower than the threshold value, but this is worth noting when
considering the difference between the criteria we set for a system and
its actual performance.

\sphinxAtStartPar
After seeing these results it is also good to evaluate the resolution of
the optimisations that we used. Our \sphinxcode{\sphinxupquote{Optimisation inputs}} CSV used
\sphinxcode{\sphinxupquote{PV size (step)}} as 5 kWp: given that the installed capacities (here
shown in the \sphinxcode{\sphinxupquote{Maximum PV size}} variable) are in the range 20\sphinxhyphen{}30 kWp,
this step size is likely too large to give us a good resolution and the
should probably have been smaller to avoid unnecessary oversizing. The
\sphinxcode{\sphinxupquote{Storage size (step)}} value of 5 kWh was probably a good choice,
however, as the storage sizes are all much larger than the step size. If
we were looking into more detail into a given optimisation, or a new set
of optimisations, it would be worthwhile re\sphinxhyphen{}running the function with a
smaller \sphinxcode{\sphinxupquote{PV size (step)}} variable. This would also likely find systems
with the value for \sphinxcode{\sphinxupquote{Blackouts}} closer to the \sphinxcode{\sphinxupquote{parameter\_value}}. If
we were designing a system for implementation, it may also be a good
idea to run a final optimisation using a smaller step size for both
variables, possibly using the actual capacities of the PV panels and
batteries that might be used, to get the most precise answer available.


\subsubsection{Incorporating further constraints}
\label{\detokenize{optimisation:incorporating-further-constraints}}
\sphinxAtStartPar
Perhaps in addition to wanting to supply electricity at the lowest LCUE,
a project developer also has a maximum budget for the lifetime of the
project (say \$50,000). This could either be a funding constraint or a
comparison to some other kind of system, for example using diesel only
(rather than solar, storage and the grid as considered here). This time
let’s plot the results in terms of the lifetime cost of the system
against the availability of electricity, both in terms of time
(\sphinxcode{\sphinxupquote{Blackouts}}) and also show the availability of energy demanded (using
\sphinxcode{\sphinxupquote{Unmet fraction}}) for some additional insight:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plt.plot(optimisation\PYGZus{}example[\PYGZsq{}Total system cost (\PYGZdl{})\PYGZsq{}]/1000,
         (1\PYGZhy{}optimisation\PYGZus{}example[\PYGZsq{}Blackouts\PYGZsq{}])*100,
        linewidth=3, label = \PYGZsq{}Time\PYGZsq{})
plt.plot(optimisation\PYGZus{}example[\PYGZsq{}Total system cost (\PYGZdl{})\PYGZsq{}]/1000,
         (1\PYGZhy{}optimisation\PYGZus{}example[\PYGZsq{}Unmet fraction\PYGZsq{}])*100,
        linewidth=3, label = \PYGZsq{}Energy\PYGZsq{})
plt.plot([50,50],[75,100], color = \PYGZsq{}k\PYGZsq{}, linestyle = \PYGZsq{}:\PYGZsq{})
plt.ylabel(\PYGZsq{}Availability (\PYGZpc{})\PYGZsq{})
plt.ylim(75,100)
plt.xlabel(\PYGZsq{}Lifetime cost (\PYGZdl{} 000s)\PYGZsq{})
plt.xlim(35,60)
plt.grid(which=\PYGZsq{}both\PYGZsq{})
plt.legend()
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_21_0_opt}.png}

\sphinxAtStartPar
In all cases the availability of energy is greater than the availability
in terms of time, suggesting that when blackouts occur they are either
at times with lower demand or power is available for at least some of
those hours when blackouts occur. It also suggests that using
\sphinxcode{\sphinxupquote{Blackouts}} as the threshold criterion is more strict and will result
in a more conservative estimate of reliability.

\sphinxAtStartPar
Here we can see that the maximum budget of \$50,000 would correspond to a
system with around power available around 92\% of the time, and would
supply 94\% of the energy demanded by the community. This is just an
estimate, however, and further optimisations around this point would
inform the actual system design and capacities necessary to achieve that
performance. Conveniently for us, however, the system found for
\sphinxcode{\sphinxupquote{Parameter value = 0.10}} matches these performances quite closely
which hints at the next steps for future optimisations: for example,
using \sphinxcode{\sphinxupquote{parameter\_values = {[}0.12, 0.11, 0.10, 0.09, 0.08{]}}} to hone in
on the best system.


\subsubsection{Considering environmental performance}
\label{\detokenize{optimisation:considering-environmental-performance}}
\sphinxAtStartPar
In this case the we designed the systems to meet a minimum level of
system performance (\sphinxcode{\sphinxupquote{Blackouts}}) at the lowest LCUE, and also added a
constraint of the total available budget of the project. Many developers
also want to know the environmental impact of the projects, both in
terms of the emissions intensity of the power provided and the total GHG
emissions.

\sphinxAtStartPar
Let’s first look at the emissions intensity:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
emissions\PYGZus{}intensity = optimisation\PYGZus{}example[[\PYGZsq{}Parameter value\PYGZsq{},\PYGZsq{}Emissions intensity (gCO2/kWh)\PYGZsq{}]]
emissions\PYGZus{}intensity.head().round(3)
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
It seems that there is not an obvious linearity here, but there are
several factors at play. The systems use approximately the same amount
of high\sphinxhyphen{}carbon grid electricity, but the higher\sphinxhyphen{}reliability systems have
a greater share of energy coming from renewable sources which will
decrease the average emissions intensity. At higher reliabilities,
however, there is a diminishing return on investment for the equipment
as more equipment (and hence more embedded emissions) are necessary for
the same incremental gains. Let’s compare to the emissions intensity of
the grid:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
print(GHG\PYGZus{}inputs.loc[18:19])
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                      \PYG{l+m+mi}{0}    \PYG{l+m+mi}{1}          \PYG{l+m+mi}{2}
\PYG{l+m+mi}{18}  \PYG{n}{Grid} \PYG{n}{GHGs} \PYG{p}{(}\PYG{n}{initial}\PYG{p}{)}  \PYG{l+m+mf}{0.8}  \PYG{n}{kgCO2}\PYG{o}{/}\PYG{n}{kWh}
\PYG{l+m+mi}{19}    \PYG{n}{Grid} \PYG{n}{GHGs} \PYG{p}{(}\PYG{n}{final}\PYG{p}{)}  \PYG{l+m+mf}{0.4}  \PYG{n}{kgCO2}\PYG{o}{/}\PYG{n}{kWh}
\end{sphinxVerbatim}

\sphinxAtStartPar
Over the lifetime of the system the average intensity of the grid is
around 600 gCO2/kWh, but for all of our systems it is between 430\sphinxhyphen{}490
gCO2/kWh, so overall these systems perform quite favourably \sphinxhyphen{} especially
bearing in mind that some of the 23\sphinxhyphen{}28\% of their energy comes from the
grid (\sphinxcode{\sphinxupquote{Grid fraction}}). Diesel\sphinxhyphen{}only systems can have emissions
intensities around 1000 gCO2/kWh, so these systems seem like a good
option. Let’s also consider the total GHG emissions from each source:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plt.bar(range(5),optimisation\PYGZus{}example[\PYGZsq{}Total system GHGs (kgCO2eq)\PYGZsq{}],
       edgecolor=\PYGZsq{}k\PYGZsq{},label=\PYGZsq{}System\PYGZsq{})
plt.bar(range(5),optimisation\PYGZus{}example[\PYGZsq{}Kerosene GHGs (kgCO2eq)\PYGZsq{}],
        bottom = optimisation\PYGZus{}example[\PYGZsq{}Total system GHGs (kgCO2eq)\PYGZsq{}],
       edgecolor=\PYGZsq{}k\PYGZsq{},label=\PYGZsq{}Kerosene\PYGZsq{})
plt.bar(range(5),optimisation\PYGZus{}example[\PYGZsq{}Kerosene GHGs mitigated (kgCO2eq)\PYGZsq{}],
        bottom = optimisation\PYGZus{}example[\PYGZsq{}Total system GHGs (kgCO2eq)\PYGZsq{}]+optimisation\PYGZus{}example[\PYGZsq{}Kerosene GHGs (kgCO2eq)\PYGZsq{}],
        facecolor=\PYGZsq{}w\PYGZsq{},edgecolor=\PYGZsq{}k\PYGZsq{},linestyle = \PYGZsq{}:\PYGZsq{},label=\PYGZsq{}Mitigated kerosene\PYGZsq{})
plt.legend(bbox\PYGZus{}to\PYGZus{}anchor=(1.0, 0.75))
plt.xticks(range(5),optimisation\PYGZus{}example[\PYGZsq{}Parameter value\PYGZsq{}])
plt.xlabel(\PYGZsq{}Blackout threshold value\PYGZsq{})
plt.yticks(range(0,600001,100000),range(0,601,100))
plt.ylabel(\PYGZsq{}Lifetime GHG emissions (tCO2eq)\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_27_0_opt}.png}

\sphinxAtStartPar
The GHGs associated with the system increase as reliability increases,
which as discussed earlier is inherent in larger systems with greater
equipment requirements. In this case, however, the impact of kerosene
usage has a significant effect: kerosene for lighting when electricity
is unavailable is very common in our case study location of Bahraich,
and by achieving higher levels of reliability our systems can offset
larger amounts of kerosene usage in the evenings. Less reliable systems,
however, provide less availability in the evening periods and so
kerosene usage remains relatively prevalent; this is also captured in
the \sphinxcode{\sphinxupquote{Kerosene displacement}} variable.

\sphinxAtStartPar
Here we can see that systems with increasing reliability lower total GHG
emissions over their lifetimes, but this diminishes between the systems
with \sphinxcode{\sphinxupquote{Parameter value = 0.1}} and \sphinxcode{\sphinxupquote{0.05}}. Given the budgetary
constraints discussed in  the section on incorporating further constraints,
let’s assume that the system with \sphinxcode{\sphinxupquote{Parameter value = 0.1}} fits our
environmental needs by significantly reducing GHGs from existing
kerosene use whilst also staying within an appropriate budget for the
project and therefore select this system for deployment.


\subsubsection{Returning to system performance}
\label{\detokenize{optimisation:returning-to-system-performance}}
\sphinxAtStartPar
Now that we’ve selected the system with \sphinxcode{\sphinxupquote{Parameter value = 0.1}} as the
one to be installed we should investigate its technical performance to
make sure that it will meet the needs of the community. Whilst this has
already been assessed during the optimisation process, this will allow
us to dive deeper into its operation to identify any potentially
unexpected results.

\sphinxAtStartPar
To do this we first use a function we mentioned earlier to open the
performance of the system from its CSV file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
chosen\PYGZus{}system = Optimisation().open\PYGZus{}optimisation(filename = \PYGZsq{}/Changing parameter example/Threshold value = 0.10\PYGZsq{})
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that here we must also specify the folder the file is stored in
(\sphinxcode{\sphinxupquote{Changing parameter optimisation}}) as the function looks in the
\sphinxcode{\sphinxupquote{Saved optimisations}} folder by default. Next we can use a function in
the \sphinxcode{\sphinxupquote{Energy\_System}} module to run a simulation for this chosen system,
automatically accounting for the equipment upgrades:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sys.path.insert(0, \PYGZsq{}/Users/prs09/Documents/CLOVER/Scripts/Simulation scripts/\PYGZsq{})
from Energy\PYGZus{}System import Energy\PYGZus{}System
chosen\PYGZus{}system\PYGZus{}simulation = Energy\PYGZus{}System().lifetime\PYGZus{}simulation(chosen\PYGZus{}system)
chosen\PYGZus{}system\PYGZus{}simulation.head(24).round(3)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Time} \PYG{n}{taken} \PYG{k}{for} \PYG{n}{simulation}\PYG{p}{:} \PYG{l+m+mf}{0.23} \PYG{n}{seconds} \PYG{n}{per} \PYG{n}{year}

\PYG{n}{Time} \PYG{n}{taken} \PYG{k}{for} \PYG{n}{simulation}\PYG{p}{:} \PYG{l+m+mf}{0.12} \PYG{n}{seconds} \PYG{n}{per} \PYG{n}{year}

\PYG{n}{Time} \PYG{n}{taken} \PYG{k}{for} \PYG{n}{simulation}\PYG{p}{:} \PYG{l+m+mf}{0.06} \PYG{n}{seconds} \PYG{n}{per} \PYG{n}{year}
\end{sphinxVerbatim}



\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
Here we have once again displayed the first day of data from this
simulation output, similarly to  the section on simulation outputs
and notice
that the output of \sphinxcode{\sphinxupquote{Energy\_System().lifetime\_simulation(...)}} gives a
single output of the system performance, rather than the additional
second output describing the makeup of that system (as we already know
it from the input we used).

\sphinxAtStartPar
As an aside, it is also possible to perform the reverse process that we
have just used: we can generate the technical, financial and
environmental outputs of a given simulation using the function
\sphinxcode{\sphinxupquote{Optimisation().system\_appraisal(chosen\_system\_simulation)}}. This
function takes the (two\sphinxhyphen{}component) variable \sphinxcode{\sphinxupquote{chosen\_system\_simulation}}
as an input, and returns the same format of appraisal results as is
generated by the standard optimisation processes. This could be useful,
for example, when assessing the performance of a specific case study
system which was not generated through the optimisation process.

\sphinxAtStartPar
Let’s look at the energy use on an average day for each of the three
iteration periods, plotted at the same scale:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
fig,([ax1,ax2,ax3]) = plt.subplots(1,3,sharex=True, sharey=True,figsize=(12,4))

\PYGZsh{}Iteration period 1
iteration\PYGZus{}length = 365 * 4
start\PYGZus{}hour = 0 * (iteration\PYGZus{}length * 24)
end\PYGZus{}hour = 1 * (iteration\PYGZus{}length * 24) \PYGZhy{} 1
iteration\PYGZus{}performance = chosen\PYGZus{}system\PYGZus{}simulation.loc[start\PYGZus{}hour:end\PYGZus{}hour]
total\PYGZus{}used = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Total energy used (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
renewable\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Renewables energy used (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
storage\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
grid\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Grid energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
diesel\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Diesel energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
unmet\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Unmet energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
renewables\PYGZus{}supplied = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Renewables energy supplied (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)

ax1.plot(total\PYGZus{}used, label = \PYGZsq{}Total used\PYGZsq{})
ax1.plot(renewable\PYGZus{}energy, label = \PYGZsq{}Solar used directly\PYGZsq{})
ax1.plot(storage\PYGZus{}energy, label = \PYGZsq{}Storage\PYGZsq{})
ax1.plot(grid\PYGZus{}energy, label = \PYGZsq{}Grid\PYGZsq{})
ax1.plot(diesel\PYGZus{}energy, label = \PYGZsq{}Diesel\PYGZsq{})
ax1.plot(unmet\PYGZus{}energy, label = \PYGZsq{}Unmet\PYGZsq{})
ax1.plot(renewables\PYGZus{}supplied, label = \PYGZsq{}Solar generated\PYGZsq{})
ax1.set(xticks = range(0,24,6),
        xlim=(0,23),
        xlabel = \PYGZsq{}Hour of day\PYGZsq{},
        ylabel = \PYGZsq{}Average energy (kWh per hour)\PYGZsq{},
        title = \PYGZsq{}Years 1\PYGZhy{}4\PYGZsq{})
ax1.legend()

\PYGZsh{}Iteration period 2
iteration\PYGZus{}length = 365 * 4
start\PYGZus{}hour = 1 * (iteration\PYGZus{}length * 24)
end\PYGZus{}hour = 2 * (iteration\PYGZus{}length * 24) \PYGZhy{} 1
iteration\PYGZus{}performance = chosen\PYGZus{}system\PYGZus{}simulation.loc[start\PYGZus{}hour:end\PYGZus{}hour]
total\PYGZus{}used = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Total energy used (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
renewable\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Renewables energy used (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
storage\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
grid\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Grid energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
diesel\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Diesel energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
unmet\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Unmet energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
renewables\PYGZus{}supplied = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Renewables energy supplied (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)

ax2.plot(total\PYGZus{}used, label = \PYGZsq{}Total used\PYGZsq{})
ax2.plot(renewable\PYGZus{}energy, label = \PYGZsq{}Solar used directly\PYGZsq{})
ax2.plot(storage\PYGZus{}energy, label = \PYGZsq{}Storage\PYGZsq{})
ax2.plot(grid\PYGZus{}energy, label = \PYGZsq{}Grid\PYGZsq{})
ax2.plot(diesel\PYGZus{}energy, label = \PYGZsq{}Diesel\PYGZsq{})
ax2.plot(unmet\PYGZus{}energy, label = \PYGZsq{}Unmet\PYGZsq{})
ax2.plot(renewables\PYGZus{}supplied, label = \PYGZsq{}Solar generated\PYGZsq{})
ax2.set(xticks = range(0,24,6),
        xlim=(0,23),
        xlabel = \PYGZsq{}Hour of day\PYGZsq{},
        title = \PYGZsq{}Years 5\PYGZhy{}8\PYGZsq{})

\PYGZsh{}Iteration period 3
iteration\PYGZus{}length = 365 * 4
start\PYGZus{}hour = 2 * (iteration\PYGZus{}length * 24)
end\PYGZus{}hour = 3 * (iteration\PYGZus{}length * 24) \PYGZhy{} 1
iteration\PYGZus{}performance = chosen\PYGZus{}system\PYGZus{}simulation.loc[start\PYGZus{}hour:end\PYGZus{}hour]
total\PYGZus{}used = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Total energy used (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
renewable\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Renewables energy used (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
storage\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Storage energy supplied (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
grid\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Grid energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
diesel\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Diesel energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
unmet\PYGZus{}energy = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Unmet energy (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)
renewables\PYGZus{}supplied = np.mean(np.reshape(iteration\PYGZus{}performance[\PYGZsq{}Renewables energy supplied (kWh)\PYGZsq{}].values,(iteration\PYGZus{}length,24)),axis=0)

ax3.plot(total\PYGZus{}used, label = \PYGZsq{}Total used\PYGZsq{})
ax3.plot(renewable\PYGZus{}energy, label = \PYGZsq{}Solar used directly\PYGZsq{})
ax3.plot(storage\PYGZus{}energy, label = \PYGZsq{}Storage\PYGZsq{})
ax3.plot(grid\PYGZus{}energy, label = \PYGZsq{}Grid\PYGZsq{})
ax3.plot(diesel\PYGZus{}energy, label = \PYGZsq{}Diesel\PYGZsq{})
ax3.plot(unmet\PYGZus{}energy, label = \PYGZsq{}Unmet\PYGZsq{})
ax3.plot(renewables\PYGZus{}supplied, label = \PYGZsq{}Solar generated\PYGZsq{})
ax3.set(xticks = range(0,24,6),
        xlim=(0,23),
        xlabel = \PYGZsq{}Hour of day\PYGZsq{},
        title = \PYGZsq{}Years 9\PYGZhy{}12\PYGZsq{})

plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_33_0_opt}.png}

\sphinxAtStartPar
We can observe here the growing energy generation and usage across the
three iteration periods and some minor variations in the relative usage
of each source of power at different points during the day, but in
general the performance seems quite similar across the three iteration
periods over the lifetime of the system. If we had further issues to
consider, for example if the load profile changed in shape over time as
well as increasing, we might need to investigate the different iteration
periods in more detail.

\sphinxAtStartPar
Now let’s look at the availability of energy, in terms of the average
proportion of blackouts per day, over the lifetime of the system:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
blackouts = pd.DataFrame(chosen\PYGZus{}system\PYGZus{}simulation[\PYGZsq{}Blackouts\PYGZsq{}])
daily\PYGZus{}blackout\PYGZus{}mean = np.mean(np.reshape(np.mean(blackouts[0:365*24*12],axis=1).values,(365*12,24)),axis=1)
lifetime\PYGZus{}mean = np.mean(daily\PYGZus{}blackout\PYGZus{}mean)
plt.figsize=(12,4)

plt.plot(range(365*12),pd.DataFrame(daily\PYGZus{}blackout\PYGZus{}mean).rolling(30).mean(), label = \PYGZsq{}30\PYGZhy{}day rolling average\PYGZsq{})
plt.plot([0,len(daily\PYGZus{}blackout\PYGZus{}mean)],[0.1,0.1],
         color = \PYGZsq{}g\PYGZsq{}, linestyle = \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZsq{}, label = \PYGZsq{}Target threshold\PYGZsq{})

plt.plot([0,len(daily\PYGZus{}blackout\PYGZus{}mean)],[lifetime\PYGZus{}mean,lifetime\PYGZus{}mean],
         color = \PYGZsq{}k\PYGZsq{}, linestyle = \PYGZsq{}:\PYGZsq{}, label = \PYGZsq{}Lifetime average\PYGZsq{})

plt.ylim(0,0.3)
plt.xlim(0,365*12)
plt.xticks(range(0,len(daily\PYGZus{}blackout\PYGZus{}mean)+1,365),range(13))
plt.legend()
plt.xlabel(\PYGZsq{}Year of lifetime\PYGZsq{})
plt.ylabel(\PYGZsq{}Proportion of day with blackouts\PYGZsq{})
plt.show()
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{output_35_0_opt}.png}

\sphinxAtStartPar
To remove some of the inherent variability between days we present the
data in terms of a 30\sphinxhyphen{}day rolling average. As we can see, the
availability of power varies quite significantly over the lifetime and
each iteration period: as the load grows, the ability of the system to
maintain the desired threshold decreases and so blackouts increase
around halfway through each iteration period. There is also a seasonal
effect, where blackouts occur more frequently in the winter months.
Let’s look at the average blackouts for each year of the lifetime:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
blackouts = pd.DataFrame(chosen\PYGZus{}system\PYGZus{}simulation[\PYGZsq{}Blackouts\PYGZsq{}])
print(\PYGZsq{}Year | Mean | Standard deviation\PYGZsq{})
for year in range(12):
    start\PYGZus{}hour = year * 365 * 24
    end\PYGZus{}hour = (year+1) * 365 * 24 \PYGZhy{} 1
    yearly\PYGZus{}blackouts = blackouts.loc[start\PYGZus{}hour:end\PYGZus{}hour]
    print(\PYGZsq{}Year \PYGZsq{}+str(year+1)+\PYGZsq{}: \PYGZsq{}+str(np.mean(yearly\PYGZus{}blackouts)[\PYGZsq{}Blackouts\PYGZsq{}].round(2))
          +str(\PYGZsq{} +/\PYGZhy{} \PYGZsq{})+str(np.std(yearly\PYGZus{}blackouts)[\PYGZsq{}Blackouts\PYGZsq{}].round(2)))
print(\PYGZsq{}Lifetime average: \PYGZsq{}+str(np.mean(blackouts)[\PYGZsq{}Blackouts\PYGZsq{}].round(2))
      +str(\PYGZsq{} +/\PYGZhy{} \PYGZsq{})+str(np.std(blackouts)[\PYGZsq{}Blackouts\PYGZsq{}].round(2)))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Year} \PYG{o}{|} \PYG{n}{Mean} \PYG{o}{|} \PYG{n}{Standard} \PYG{n}{deviation}
\PYG{n}{Year} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mf}{0.01} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.11}
\PYG{n}{Year} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+m+mf}{0.04} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.19}
\PYG{n}{Year} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{l+m+mf}{0.07} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.26}
\PYG{n}{Year} \PYG{l+m+mi}{4}\PYG{p}{:} \PYG{l+m+mf}{0.14} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.35}
\PYG{n}{Year} \PYG{l+m+mi}{5}\PYG{p}{:} \PYG{l+m+mf}{0.01} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.12}
\PYG{n}{Year} \PYG{l+m+mi}{6}\PYG{p}{:} \PYG{l+m+mf}{0.06} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.24}
\PYG{n}{Year} \PYG{l+m+mi}{7}\PYG{p}{:} \PYG{l+m+mf}{0.11} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.32}
\PYG{n}{Year} \PYG{l+m+mi}{8}\PYG{p}{:} \PYG{l+m+mf}{0.17} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.37}
\PYG{n}{Year} \PYG{l+m+mi}{9}\PYG{p}{:} \PYG{l+m+mf}{0.05} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.21}
\PYG{n}{Year} \PYG{l+m+mi}{10}\PYG{p}{:} \PYG{l+m+mf}{0.07} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.26}
\PYG{n}{Year} \PYG{l+m+mi}{11}\PYG{p}{:} \PYG{l+m+mf}{0.12} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.32}
\PYG{n}{Year} \PYG{l+m+mi}{12}\PYG{p}{:} \PYG{l+m+mf}{0.17} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.37}
\PYG{n}{Lifetime} \PYG{n}{average}\PYG{p}{:} \PYG{l+m+mf}{0.08} \PYG{o}{+}\PYG{o}{/}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.28}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first two years in each iteration period (1\sphinxhyphen{}2, 5\sphinxhyphen{}6, 9\sphinxhyphen{}10) perform
better than expected, but the final years (4, 8, 12) all have far more
blackouts than our threshold value (\sphinxcode{\sphinxupquote{0.10}}) or the lifetime average.
These later years also have larger standard deviations, which means that
some days have more variable performances, also visible in the figure
above.

\sphinxAtStartPar
This could pose a problem for system operators: although customers will
receive an adequate service on average, during the winter months or the
later years they might not pay their monthly bills (for example) if
their service has not met the levels promised to them. This will affect
the financial returns of the project, as well as potentially influence
community perception of the system.

\sphinxAtStartPar
If these periods of reduced availability will be an issue we have a few
options to improve the system design. The first would be to re\sphinxhyphen{}optimise
the system using a more restrictive threshold criterion: this will
likely lower both the mean for each iteration period and the lifetime
average, but the same changing profile will probably still be present
(albeit exceeding the initial threshold of \sphinxcode{\sphinxupquote{Blackouts = 0.10}} less
frequently). Another option would be to shorten the lifetime period,
allowing the system to be resized more frequently to better account for
the growing load profile and have a more consistent incidence of
blackouts. Finally in practice it may be pragmatic to install the system
as designed here but monitor its performance: if the load profile grows
over time as expected the system could be revisited earlier than
expected to maintain the desired performance, or if not then new
equipment could be installed later.


\subsubsection{Practical considerations}
\label{\detokenize{optimisation:practical-considerations}}
\sphinxAtStartPar
CLOVER is designed for users to model community electricity systems,
simulate their performance, and identify optimum configurations based on
the inputs they choose. The simulation and optimisation functions, and
CLOVER in general, will provide results which can inform system design
for practical deployment but should always be treated with appropriate
caution. The confidence you have in your input data, for example, can be
used as a good judge of the confidence you have in the results of using
CLOVER.

\sphinxAtStartPar
This is not to say that all of the modelling is purely theoretical:
CLOVER should be used as a tool to help inform research or practical
system deployment in the context of many other activities such as
community engagement, political priorities, business model development
and technical equipment specifications. These practical considerations
are sometimes impossible to quantify and so should be dealt with
separately to ensure they are properly accounted for as part of a
project, and should inform (and be informed by) modelling in CLOVER
wherever possible.

\sphinxAtStartPar
The greatest value that CLOVER can bring to a project is its ability to
(relatively) quickly and easily explore many different scenarios and
provide results on the design and performance of systems that can be
explored in detail. Questions around providing different levels of
service to a community, using different types of energy technologies,
and under different load growth scenarios and grid availabilities can
all be answered using CLOVER, with the results considering more than
just the cost of electricity but many other performance, financial and
environmental metrics to best understand the implications of a given
system.

\sphinxAtStartPar
Once CLOVER has been used to identify a system which would be a good
candidate for deployment then the considerations around the equipment to
be installed, the topography of the distribution network, the customers
to be connected, the payment structures, the overall business model and
many other practical points can be brought in to interrogate the
appropriateness of the proposed system. These are beyond the scope and
capabilities of CLOVER and will rely on the expertise of the user or
their team to best identify how to implement a system which can provide
reliable, affordable and sustainable electricity to the communities they
aim to serve.


\section{CLOVER development}
\label{\detokenize{get_involved:clover-development}}\label{\detokenize{get_involved::doc}}

\subsection{Improvements to CLOVER}
\label{\detokenize{get_involved:improvements-to-clover}}
\sphinxAtStartPar
CLOVER is under continuous development to improve its functionality and
capabilities. These will be added to the \sphinxhref{https://github.com/phil-sandwell/CLOVER}{CLOVER repository on
GitHub} once they have been
finalised and tested, as well as any existing or new bugs that are
identified in the code. Check back in at the repository to see any new
developments to the code and bug fixes, recorded as commits and in the
update register, to ensure your version of CLOVER is up to date.


\subsection{Acknowledgements and support for CLOVER}
\label{\detokenize{get_involved:acknowledgements-and-support-for-clover}}
\sphinxAtStartPar
CLOVER has been under development since 2015 and has received a support
from a variety of funding sources. We would like to gratefully
acknowledge the support of the Grantham Institute \sphinxhyphen{} Climate Change and
the Environment for contributions to PhD scholarships, Climate\sphinxhyphen{}KIC for
research allowances, the Engineering and Physical Sciences Research
Council (EP/R511547/1 and EP/R030235/1), the ClimateWorks Foundation,
and Research England GCRF QR Funding.

\sphinxAtStartPar
Philip Sandwell would like to thank Hamish Beath, Javier Baranda Alonso,
and Scot Wheeler, under the supervision of Ned Ekins\sphinxhyphen{}Daukes and Jenny
Nelson, for their contributions to developing the CLOVER code and
functionality over the years. In addition he would like to thank Oytun
Babacan, Paloma Ortega Arriaga and Anaïs Matthey\sphinxhyphen{}Junod for their
comments and suggestions to improve this user manual.


\subsection{Get involved}
\label{\detokenize{get_involved:get-involved}}
\sphinxAtStartPar
If you would like to be involved with the development of CLOVER, have
suggestions for improvements to its functionality, or identify (or
solve) any bugs, please \sphinxhref{mailto:philip.sandwell@gmail.com}{get in
touch} or submit pull requests on
GitHub.

\sphinxAtStartPar
CLOVER is entirely open\sphinxhyphen{}source and so users are encouraged to
use the code, make modifications, and develop improvements to suit their
unique purposes under the share\sphinxhyphen{}and\sphinxhyphen{}share\sphinxhyphen{}alike conditions of the
license. We are always happy to hear about how CLOVER has been used!


\section{License}
\label{\detokenize{license:license}}\label{\detokenize{license::doc}}
\sphinxAtStartPar
MIT License, Copyright 2018 Philip Richard Sandwell

\sphinxAtStartPar
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

\sphinxAtStartPar
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

\sphinxAtStartPar
THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



\renewcommand{\indexname}{Index}
\printindex
\end{document}